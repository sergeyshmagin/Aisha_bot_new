# Архитектура проекта Aisha Bot

## Общая структура

```
Aisha_bot_new/
  backend_api/         # Backend FastAPI (GFPGAN, интеграции)
  database/            # Миграции, схемы, дампы (если есть)
  frontend_bot/        # Telegram-бот: хендлеры, сервисы, shared-модули
    handlers/          # Хендлеры (FSM, галерея, загрузка фото, подтверждение и др.)
    services/          # Бизнес-логика, работа с файлами, интеграции
    shared/            # Общие утилиты, прогресс-бары, очистка сообщений
    texts/             # Шаблоны сообщений, caption, ошибки (только в frontend_bot/texts/ и подпапках)
    keyboards/         # Генераторы клавиатур (inline/reply)
    constants/         # Константы, emoji, лимиты
    utils/             # Вспомогательные функции (валидация, логирование)
  docs/                # Документация, best practices, архитектура
  storage/             # Файлы пользователей (аватары, транскрипты)
  templates/           # Шаблоны Word/Docx и др.
  .env                 # Переменные окружения
  requirements.txt     # Зависимости
```

## Принципы архитектуры

- **handlers/** — только маршрутизация, минимум логики, максимум делегирования в сервисы.
- **services/** — бизнес-логика, работа с файлами, интеграции с внешними сервисами.
- **shared/** — общие утилиты, прогресс-бары, функции очистки сообщений, которые используются в разных частях проекта.
- **frontend_bot/texts/** — шаблоны сообщений, caption, ошибки. Все тексты централизованы только здесь и в подпапках.
- **keyboards/** — генераторы клавиатур (inline/reply), все клавиатуры централизованы.
- **constants/** — лимиты, emoji, статусы, пути, используемые во всём проекте.
- **utils/** — валидация, логирование, вспомогательные функции.

## Расширяемость

- Все новые шаблоны сообщений, caption, ошибки — только в frontend_bot/texts/ и подпапках
- Все новые клавиатуры — только в keyboards/
- Все новые прогресс-бары, shared-утилиты — только в shared/
- Бизнес-логику выносить в services/
- Хендлеры должны быть максимально тонкими.

## Асинхронность

- Все операции с файлами — только через aiofiles и асинхронные аналоги.
- Внешние процессы (ffmpeg, docx) — через asyncio.create_subprocess_exec.
- Глобальные словари для сессий и буферов — временное решение, планируется переход на Redis.

## Документирование

- Все публичные функции должны иметь docstring с описанием назначения, параметров и возвращаемого значения.
- Вся архитектурная и best practices документация — в docs/.

## Структура тестов (2024)

- Каждый смысловой блок (summary, mom, todo, word, history, delete, avatar) вынесен в отдельный файл в tests/handlers/.
- Все общие фикстуры (user_transcripts, fake_user_id, fake_txt_file, mock_bot, mock_avatar_workflow) вынесены в conftest.py.
- В каждом тесте используются user-friendly assert-сообщения.
- Нет дублирования кода, все тесты используют общие фикстуры.
- Все тесты async-compatible, используют pytest-asyncio и async-моки.

### Структура тестов для аватаров

```
tests/handlers/
├── test_avatar_handlers.py    # Основные тесты обработчиков аватаров
├── test_avatar_gallery.py     # Тесты галереи аватаров
└── test_avatar_fsm.py         # Тесты конечного автомата
```

### Фикстуры для тестирования аватаров

1. mock_bot - мок для Telegram бота
2. mock_avatar_workflow - мок для всех операций с аватарами
3. mock_state_manager - мок для управления состоянием
4. create_test_photo_message - создание тестового сообщения с фото
5. create_test_text_message - создание тестового текстового сообщения

### Примеры тестов для аватаров

1. Тесты загрузки фото:
   - Успешная загрузка
   - Ошибка валидации
   - Недостаточное количество фото

2. Тесты выбора пола:
   - Успешный выбор
   - Неверный ввод
   - Очистка состояния при ошибке

3. Тесты ввода имени:
   - Успешный ввод
   - Пустое имя
   - Очистка состояния при ошибке

4. Тесты подтверждения:
   - Успешное создание
   - Ошибка финализации
   - Очистка состояния при ошибке

### Правила тестирования аватаров

1. Всегда проверять вызов cleanup_state при ошибках
2. Проверять корректность переходов между состояниями
3. Валидировать входные данные
4. Использовать константы для лимитов (AVATAR_MIN_PHOTOS, AVATAR_MAX_PHOTOS)
5. Проверять корректность сообщений об ошибках

## Протоколы и тестирование (2024)

- Все хендлеры протоколов (MoM, summary, todo, Word) используют только асинхронные операции с файлами (aiofiles.open, async_exists и др.).
- Вся бизнес-логика генерации протоколов вынесена в сервисы, хендлеры только маршрутизируют и вызывают сервисы.
- Все smoke-тесты для протоколов проверяют только факт отправки файла (или сообщения об ошибке) и что файл не пустой, не завися от конкретного текста.
- Для файловых операций в тестах используются только async-compatible моки (AsyncMock, patch, собственные async-контекстные менеджеры).
- Если требуется мокать aiofiles.open глобально, это делается только внутри области теста, чтобы не ломать работу других сервисов (например, user_transcripts_store).

## Структура проекта

```
frontend_bot/
├── config/                 # Конфигурация
├── handlers/              # Обработчики команд
├── services/             # Бизнес-логика
├── shared/               # Общие утилиты
│   ├── file_operations.py  # Асинхронные операции с файлами
│   ├── state_manager.py    # Управление состоянием
│   └── image_processing.py # Обработка изображений
├── tests/                # Тесты
└── utils/                # Вспомогательные функции
```

## Работа с файлами

### AsyncFileManager
- Централизованный класс для всех файловых операций
- Асинхронные методы для работы с файлами
- Безопасное удаление файлов и директорий
- Логирование всех операций

### Основные операции
- `ensure_dir`: Создание директории
- `safe_remove`: Безопасное удаление файла
- `safe_rmtree`: Безопасное удаление директории
- `exists`: Проверка существования
- `get_size`: Получение размера файла
- `list_dir`: Получение списка файлов
- `read_file`: Чтение текстового файла
- `write_file`: Запись текстового файла
- `read_binary`: Чтение бинарного файла
- `write_binary`: Запись бинарного файла

### Безопасность
- Все пути типа `Path`
- Проверка размеров файлов
- Валидация типов файлов
- Уникальные имена файлов

### Обработка ошибок
- Обработка всех исключений
- Безопасное удаление
- Логирование ошибок
- Проверка существования

## Работа с состоянием

### StateManager
- Хранение состояний в Redis
- Сериализация в JSON
- TTL для автоматической очистки
- Транзакции для атомарных операций

### Основные операции
- `get_state`: Получение состояния
- `set_state`: Установка состояния
- `clear_state`: Очистка состояния
- `cleanup_state`: Полная очистка

### Безопасность
- Валидация состояний
- Очистка при ошибках
- Логирование изменений
- Транзакции

### Обработка ошибок
- Обработка всех исключений
- Очистка при ошибках
- Логирование ошибок
- Проверка валидности

## Работа с API

### HTTP-клиенты
- `aiohttp` для HTTP-запросов
- `httpx.AsyncClient` для альтернативы
- Таймауты для всех запросов
- Retry для временных ошибок

### Безопасность
- API-ключи в переменных окружения
- HTTPS для всех запросов
- Валидация входных данных
- Ограничение размера запросов

### Обработка ошибок
- Обработка всех ошибок API
- Retry для временных ошибок
- Логирование ошибок
- Понятные сообщения

## Работа с базой данных

### Драйверы
- `asyncpg` для PostgreSQL
- SQLAlchemy 2.0 для ORM
- Connection pool
- Асинхронные операции

### Безопасность
- Параметризованные запросы
- Валидация входных данных
- Миграции для изменений схемы
- Ограничение прав доступа

### Обработка ошибок
- Обработка всех ошибок БД
- Транзакции для атомарных операций
- Логирование ошибок
- Понятные сообщения

## Работа с логами

### Форматирование
- Структурированное логирование
- Контекст в логах
- Разные уровни логирования
- Читаемые сообщения

### Обработка ошибок
- Логирование всех исключений
- Стек вызовов
- Контекст ошибки
- Правильные уровни

## Работа с тестами

### Структура
- Независимые тесты
- Фикстуры для подготовки данных
- Очистка после тестов
- Группировка по функциональности

### Асинхронность
- `pytest-asyncio`
- Тестирование асинхронных функций
- Обработка ошибок
- Таймауты

### Моки
- Моки для внешних зависимостей
- Проверка вызовов
- Разные сценарии
- Очистка после тестов

### Покрытие
- 100% покрытие кода
- Граничные случаи
- Обработка ошибок
- Параметризованные тесты

## Структура меню и переходы

### Основное меню
- 🧑‍🎨 ИИ фотограф
- ✨ Улучшить фото
- 🎙 Транскрибация
- 💬 Бизнес-ассистент
- ⚙️ Настройки

### ИИ фотограф (ai_photographer)
- 📷 Создать аватар
- 👁 Просмотреть аватары
- 🖼 Образы
- ⬅️ Назад (→ основное меню)

### Мои аватары (my_avatars)
- 📷 Создать аватар
- 👁 Просмотреть аватары
- ⬅️ Назад (→ ИИ фотограф)

### Создание аватара (avatar_wizard)
1. Загрузка фото (avatar_photo_upload)
2. Выбор пола (avatar_type)
3. Ввод имени (avatar_enter_name)
4. Подтверждение (avatar_confirm)

### Правила переходов между состояниями

1. Основное меню → ИИ фотограф
   - Триггер: Нажатие "🧑‍🎨 ИИ фотограф"
   - Состояние: ai_photographer
   - Очистка: Нет

2. ИИ фотограф → Мои аватары
   - Триггер: Нажатие "🖼 Мои аватары"
   - Состояние: my_avatars
   - Очистка: Нет

3. Мои аватары → Создание аватара
   - Триггер: Нажатие "📷 Создать аватар"
   - Состояние: avatar_photo_upload
   - Очистка: Да (cleanup_state)

4. Создание аватара (последовательность):
   - avatar_photo_upload → avatar_type
     * Триггер: Успешная загрузка фото
     * Очистка: Нет
   - avatar_type → avatar_enter_name
     * Триггер: Успешный выбор пола
     * Очистка: Нет
   - avatar_enter_name → avatar_confirm
     * Триггер: Успешный ввод имени
     * Очистка: Нет
   - avatar_confirm → my_avatars
     * Триггер: Успешное подтверждение
     * Очистка: Да (cleanup_state)

5. Возврат на уровень выше:
   - Мои аватары → ИИ фотограф
     * Триггер: Нажатие "⬅️ Назад"
     * Очистка: Нет
   - ИИ фотограф → Основное меню
     * Триггер: Нажатие "⬅️ Назад"
     * Очистка: Нет
   - Любое состояние создания аватара → Мои аватары
     * Триггер: Нажатие "⬅️ Назад" или "Отмена"
     * Очистка: Да (cleanup_state)

6. Обработка ошибок:
   - При любой ошибке валидации → Мои аватары
   - При ошибке загрузки фото → Мои аватары
   - При ошибке выбора пола → Мои аватары
   - При ошибке ввода имени → Мои аватары
   - При ошибке подтверждения → Мои аватары
   - Всегда вызывать cleanup_state при ошибках

### Порядок регистрации хендлеров

- Все универсальные хендлеры (`func=lambda m: True`, `content_types=["text"]`) должны регистрироваться строго после всех специфичных хендлеров.
- Нарушение этого правила приводит к тому, что reply-кнопки и специфичные сценарии не работают, так как универсальный хендлер перехватывает все сообщения.
- Импорты файлов с универсальными хендлерами должны быть в самом конце (например, в main.py).

### Правила и ограничения

1. Все переходы между меню только через сервисные функции
2. Состояние пользователя хранится в state_manager
3. Хендлеры только маршрутизируют, бизнес-логика в services/
4. Тексты сообщений только из texts/
5. Клавиатуры только из keyboards/
6. При ошибках всегда вызывать cleanup_state
7. Использовать константы для лимитов (AVATAR_MIN_PHOTOS, AVATAR_MAX_PHOTOS)

## Тестирование переходов

Для каждого перехода между меню необходимо написать тест, проверяющий:
1. Корректность изменения состояния
2. Отправку правильного сообщения
3. Установку правильной клавиатуры
4. Очистку предыдущего состояния где необходимо

Тесты должны быть асинхронными и использовать pytest-asyncio.

# Архитектура Telegram-бота

## Централизованный bot и регистрация хендлеров

- Объект `bot` создаётся только в `frontend_bot/bot_instance.py`.
- Все хендлеры импортируют bot только из этого файла.
- В точке входа (`main.py`) импортируются все хендлеры для их регистрации.
- polling запускается только на этом экземпляре bot.
- **Дублирование экземпляра бота (например, через frontend_bot/bot.py) запрещено!** Это приводит к неработающим хендлерам и ошибкам импорта.
- Такой подход предотвращает циклические импорты и гарантирует корректную работу всех хендлеров.

### Пример структуры

- `frontend_bot/bot_instance.py`:
  ```python
  import os
  from dotenv import load_dotenv
  from telebot.async_telebot import AsyncTeleBot
  load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "../.env"))
  TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
  bot = AsyncTeleBot(TELEGRAM_TOKEN)
  ```
- `frontend_bot/main.py`:
  ```python
  from frontend_bot.bot_instance import bot
  import frontend_bot.handlers.general
  ... # все остальные хендлеры
  if __name__ == "__main__":
      import asyncio
      asyncio.run(bot.polling())
  ```
- Все хендлеры:
  ```python
  from frontend_bot.bot_instance import bot
  ```

## DRY для работы с транскриптами
- Проверки наличия, чтения и ошибок транскрипта реализованы в утилите `get_user_transcript_or_error` (`services/transcript_utils.py`).
- Хендлеры используют только эту функцию, не дублируют логику.
- Это ускоряет разработку и снижает количество багов при изменениях.

- Для отправки файлов и сообщений об ошибке используйте shared-утилиты (`send_document_with_caption`, `send_transcript_error` в `services/transcript_utils.py`).
- Не дублируйте вызовы bot.send_document и bot.send_message в каждом хендлере.

## Централизация промтов для GPT

- Все промты для GPT (транскрибация, резюме, MoM, ToDo, протоколы и др.) должны храниться только в отдельном модуле, например, `frontend_bot/GPT_Prompts/transcribe/prompts.py`.
- В хендлерах и сервисах запрещено дублировать или захардкоживать промты — только импортировать из централизованного файла.
- Это облегчает поддержку, локализацию и переиспользование промтов.

## Источник истины: get_current_avatar_id

- Функция `get_current_avatar_id` должна импортироваться только из `frontend_bot/services/avatar_manager.py`.
- Дублирование или заглушки в других сервисах запрещены.
- Использование в хендлерах, валидаторах и сервисах — только через avatar_manager.
- Причина: avatar_manager хранит актуальное состояние avatar_id пользователя (in-memory).

## Валидация фото (размер, формат, дубликаты)

- Вся валидация фото (размер, формат, дубликаты) реализована только в функции `validate_photo` из `frontend_bot/services/avatar_manager.py`.
- Использование любых других функций для проверки фото запрещено.
- Все новые хендлеры и сервисы должны вызывать только эту функцию.
- Параметры валидации (минимальный размер, поддерживаемые форматы) берутся из config.
