# Архитектура проекта Aisha Bot

## Общая структура

```
Aisha_bot_new/
  backend_api/         # Backend FastAPI (GFPGAN, интеграции)
  database/            # Миграции, схемы, дампы (если есть)
  frontend_bot/        # Telegram-бот: хендлеры, сервисы, shared-модули
    handlers/          # Хендлеры (FSM, галерея, загрузка фото, подтверждение и др.)
    services/          # Бизнес-логика, работа с файлами, интеграции
    shared/            # Общие утилиты, прогресс-бары, очистка сообщений
    texts/             # Шаблоны сообщений, caption, ошибки (только в frontend_bot/texts/ и подпапках)
    keyboards/         # Генераторы клавиатур (inline/reply)
    constants/         # Константы, emoji, лимиты
    utils/             # Вспомогательные функции (валидация, логирование)
  docs/                # Документация, best practices, архитектура
  storage/             # Файлы пользователей (аватары, транскрипты)
  templates/           # Шаблоны Word/Docx и др.
  .env                 # Переменные окружения
  requirements.txt     # Зависимости
```

## Принципы архитектуры

- **handlers/** — только маршрутизация, минимум логики, максимум делегирования в сервисы.
- **services/** — бизнес-логика, работа с файлами, интеграции с внешними сервисами.
- **shared/** — общие утилиты, прогресс-бары, функции очистки сообщений, которые используются в разных частях проекта.
- **frontend_bot/texts/** — шаблоны сообщений, caption, ошибки. Все тексты централизованы только здесь и в подпапках.
- **keyboards/** — генераторы клавиатур (inline/reply), все клавиатуры централизованы.
- **constants/** — лимиты, emoji, статусы, пути, используемые во всём проекте.
- **utils/** — валидация, логирование, вспомогательные функции.

## Расширяемость

- Все новые шаблоны сообщений, caption, ошибки — только в frontend_bot/texts/ и подпапках
- Все новые клавиатуры — только в keyboards/
- Все новые прогресс-бары, shared-утилиты — только в shared/
- Бизнес-логику выносить в services/
- Хендлеры должны быть максимально тонкими.

## Асинхронность

- Все операции с файлами — только через aiofiles и асинхронные аналоги.
- Внешние процессы (ffmpeg, docx) — через asyncio.create_subprocess_exec.
- Глобальные словари для сессий и буферов — временное решение, планируется переход на Redis.

## Документирование

- Все публичные функции должны иметь docstring с описанием назначения, параметров и возвращаемого значения.
- Вся архитектурная и best practices документация — в docs/.

## Структура тестов (2024)

- Каждый смысловой блок (summary, mom, todo, word, history, delete, avatar) вынесен в отдельный файл в tests/handlers/.
- Все общие фикстуры (user_transcripts, fake_user_id, fake_txt_file, mock_bot, mock_avatar_workflow) вынесены в conftest.py.
- В каждом тесте используются user-friendly assert-сообщения.
- Нет дублирования кода, все тесты используют общие фикстуры.
- Все тесты async-compatible, используют pytest-asyncio и async-моки.

### Структура тестов для аватаров

```
tests/handlers/
├── test_avatar_handlers.py    # Основные тесты обработчиков аватаров
├── test_avatar_gallery.py     # Тесты галереи аватаров
└── test_avatar_fsm.py         # Тесты конечного автомата
```

### Фикстуры для тестирования аватаров

1. mock_bot - мок для Telegram бота
2. mock_avatar_workflow - мок для всех операций с аватарами
3. mock_state_manager - мок для управления состоянием
4. create_test_photo_message - создание тестового сообщения с фото
5. create_test_text_message - создание тестового текстового сообщения

### Примеры тестов для аватаров

1. Тесты загрузки фото:
   - Успешная загрузка
   - Ошибка валидации
   - Недостаточное количество фото

2. Тесты выбора пола:
   - Успешный выбор
   - Неверный ввод
   - Очистка состояния при ошибке

3. Тесты ввода имени:
   - Успешный ввод
   - Пустое имя
   - Очистка состояния при ошибке

4. Тесты подтверждения:
   - Успешное создание
   - Ошибка финализации
   - Очистка состояния при ошибке

### Правила тестирования аватаров

1. Всегда проверять вызов cleanup_state при ошибках
2. Проверять корректность переходов между состояниями
3. Валидировать входные данные
4. Использовать константы для лимитов (AVATAR_MIN_PHOTOS, AVATAR_MAX_PHOTOS)
5. Проверять корректность сообщений об ошибках

## Протоколы и тестирование (2024)

- Все хендлеры протоколов (MoM, summary, todo, Word) используют только асинхронные операции с файлами (aiofiles.open, async_exists и др.).
- Вся бизнес-логика генерации протоколов вынесена в сервисы, хендлеры только маршрутизируют и вызывают сервисы.
- Все smoke-тесты для протоколов проверяют только факт отправки файла (или сообщения об ошибке) и что файл не пустой, не завися от конкретного текста.
- Для файловых операций в тестах используются только async-compatible моки (AsyncMock, patch, собственные async-контекстные менеджеры).
- Если требуется мокать aiofiles.open глобально, это делается только внутри области теста, чтобы не ломать работу других сервисов (например, transcript_cache).

## Структура проекта

```
frontend_bot/
├── config/                 # Конфигурация
├── handlers/              # Обработчики команд
├── services/             # Бизнес-логика
├── shared/               # Общие утилиты
│   ├── file_operations.py  # Асинхронные операции с файлами
│   ├── state_manager.py    # Управление состоянием
│   └── image_processing.py # Обработка изображений
├── tests/                # Тесты
└── utils/                # Вспомогательные функции
```

## Работа с файлами

### AsyncFileManager
- Централизованный класс для всех файловых операций
- Асинхронные методы для работы с файлами
- Безопасное удаление файлов и директорий
- Логирование всех операций

### Основные операции
- `ensure_dir`: Создание директории
- `safe_remove`: Безопасное удаление файла
- `safe_rmtree`: Безопасное удаление директории
- `exists`: Проверка существования
- `get_size`: Получение размера файла
- `list_dir`: Получение списка файлов
- `read_file`: Чтение текстового файла
- `write_file`: Запись текстового файла
- `read_binary`: Чтение бинарного файла
- `write_binary`: Запись бинарного файла

### Безопасность
- Все пути типа `Path`
- Проверка размеров файлов
- Валидация типов файлов
- Уникальные имена файлов

### Обработка ошибок
- Обработка всех исключений
- Безопасное удаление
- Логирование ошибок
- Проверка существования

## Работа с состоянием

### StateManager
- Хранение состояний в Redis
- Сериализация в JSON
- TTL для автоматической очистки
- Транзакции для атомарных операций

### Основные операции
- `get_state`: Получение состояния
- `set_state`: Установка состояния
- `clear_state`: Очистка состояния
- `cleanup_state`: Полная очистка

### Безопасность
- Валидация состояний
- Очистка при ошибках
- Логирование изменений
- Транзакции

### Обработка ошибок
- Обработка всех исключений
- Очистка при ошибках
- Логирование ошибок
- Проверка валидности

## Работа с API

### HTTP-клиенты
- `aiohttp` для HTTP-запросов
- `httpx.AsyncClient` для альтернативы
- Таймауты для всех запросов
- Retry для временных ошибок

### Безопасность
- API-ключи в переменных окружения
- HTTPS для всех запросов
- Валидация входных данных
- Ограничение размера запросов

### Обработка ошибок
- Обработка всех ошибок API
- Retry для временных ошибок
- Логирование ошибок
- Понятные сообщения

## Работа с базой данных

### Драйверы
- `asyncpg` для PostgreSQL
- SQLAlchemy 2.0 для ORM
- Connection pool
- Асинхронные операции

### Безопасность
- Параметризованные запросы
- Валидация входных данных
- Миграции для изменений схемы
- Ограничение прав доступа

### Обработка ошибок
- Обработка всех ошибок БД
- Транзакции для атомарных операций
- Логирование ошибок
- Понятные сообщения

## Работа с логами

### Форматирование
- Структурированное логирование
- Контекст в логах
- Разные уровни логирования
- Читаемые сообщения

### Обработка ошибок
- Логирование всех исключений
- Стек вызовов
- Контекст ошибки
- Правильные уровни

## Работа с тестами

### Структура
- Независимые тесты
- Фикстуры для подготовки данных
- Очистка после тестов
- Группировка по функциональности

### Асинхронность
- `pytest-asyncio`
- Тестирование асинхронных функций
- Обработка ошибок
- Таймауты

### Моки
- Моки для внешних зависимостей
- Проверка вызовов
- Разные сценарии
- Очистка после тестов

### Покрытие
- 100% покрытие кода
- Граничные случаи
- Обработка ошибок
- Параметризованные тесты

## Структура меню и переходы

### Основное меню
- 🧑‍🎨 ИИ фотограф
- ✨ Улучшить фото
- 🎙 Транскрибация
- 💬 Бизнес-ассистент
- ⚙️ Настройки

### ИИ фотограф (ai_photographer)
- 📷 Создать аватар
- 👁 Просмотреть аватары
- 🖼 Образы
- ⬅️ Назад (→ основное меню)

### Мои аватары (my_avatars)
- 📷 Создать аватар
- 👁 Просмотреть аватары
- ⬅️ Назад (→ ИИ фотограф)

### Создание аватара (avatar_wizard)
1. Загрузка фото (avatar_photo_upload)
2. Выбор пола (avatar_type)
3. Ввод имени (avatar_enter_name)
4. Подтверждение (avatar_confirm)

### Правила переходов между состояниями

1. Основное меню → ИИ фотограф
   - Триггер: Нажатие "🧑‍🎨 ИИ фотограф"
   - Состояние: ai_photographer
   - Очистка: Нет

2. ИИ фотограф → Мои аватары
   - Триггер: Нажатие "🖼 Мои аватары"
   - Состояние: my_avatars
   - Очистка: Нет

3. Мои аватары → Создание аватара
   - Триггер: Нажатие "📷 Создать аватар"
   - Состояние: avatar_photo_upload
   - Очистка: Да (cleanup_state)

4. Создание аватара (последовательность):
   - avatar_photo_upload → avatar_type
     * Триггер: Успешная загрузка фото
     * Очистка: Нет
   - avatar_type → avatar_enter_name
     * Триггер: Успешный выбор пола
     * Очистка: Нет
   - avatar_enter_name → avatar_confirm
     * Триггер: Успешный ввод имени
     * Очистка: Нет
   - avatar_confirm → my_avatars
     * Триггер: Успешное подтверждение
     * Очистка: Да (cleanup_state)

5. Возврат на уровень выше:
   - Мои аватары → ИИ фотограф
     * Триггер: Нажатие "⬅️ Назад"
     * Очистка: Нет
   - ИИ фотограф → Основное меню
     * Триггер: Нажатие "⬅️ Назад"
     * Очистка: Нет
   - Любое состояние создания аватара → Мои аватары
     * Триггер: Нажатие "⬅️ Назад" или "Отмена"
     * Очистка: Да (cleanup_state)

6. Обработка ошибок:
   - При любой ошибке валидации → Мои аватары
   - При ошибке загрузки фото → Мои аватары
   - При ошибке выбора пола → Мои аватары
   - При ошибке ввода имени → Мои аватары
   - При ошибке подтверждения → Мои аватары
   - Всегда вызывать cleanup_state при ошибках

### Порядок регистрации хендлеров

- Все универсальные хендлеры (`func=lambda m: True`, `content_types=["text"]`) должны регистрироваться строго после всех специфичных хендлеров.
- Нарушение этого правила приводит к тому, что reply-кнопки и специфичные сценарии не работают, так как универсальный хендлер перехватывает все сообщения.
- Импорты файлов с универсальными хендлерами должны быть в самом конце (например, в main.py).

### Правила и ограничения

1. Все переходы между меню только через сервисные функции
2. Состояние пользователя хранится в state_manager
3. Хендлеры только маршрутизируют, бизнес-логика в services/
4. Тексты сообщений только из texts/
5. Клавиатуры только из keyboards/
6. При ошибках всегда вызывать cleanup_state
7. Использовать константы для лимитов (AVATAR_MIN_PHOTOS, AVATAR_MAX_PHOTOS)

## Тестирование переходов

Для каждого перехода между меню необходимо написать тест, проверяющий:
1. Корректность изменения состояния
2. Отправку правильного сообщения
3. Установку правильной клавиатуры
4. Очистку предыдущего состояния где необходимо

Тесты должны быть асинхронными и использовать pytest-asyncio.

# Архитектура Telegram-бота

## Централизованный bot и регистрация хендлеров

- Объект `bot` создаётся только в `frontend_bot/bot_instance.py`.
- Все хендлеры импортируют bot только из этого файла.
- В точке входа (`main.py`) импортируются все хендлеры для их регистрации.
- polling запускается только на этом экземпляре bot.
- **Дублирование экземпляра бота (например, через frontend_bot/bot.py) запрещено!** Это приводит к неработающим хендлерам и ошибкам импорта.
- Такой подход предотвращает циклические импорты и гарантирует корректную работу всех хендлеров.

### Пример структуры

- `frontend_bot/bot_instance.py`:
  ```python
  import os
  from dotenv import load_dotenv
  from telebot.async_telebot import AsyncTeleBot
  load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "../.env"))
  TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
  bot = AsyncTeleBot(TELEGRAM_TOKEN)
  ```
- `frontend_bot/main.py`:
  ```python
  from frontend_bot.bot_instance import bot
  import frontend_bot.handlers.general
  ... # все остальные хендлеры
  if __name__ == "__main__":
      import asyncio
      asyncio.run(bot.polling())
  ```
- Все хендлеры:
  ```python
  from frontend_bot.bot_instance import bot
  ```

## DRY для работы с транскриптами
- Проверки наличия, чтения и ошибок транскрипта реализованы в утилите `get_user_transcript_or_error` (`services/transcript_utils.py`).
- Хендлеры используют только эту функцию, не дублируют логику.
- Это ускоряет разработку и снижает количество багов при изменениях.

- Для отправки файлов и сообщений об ошибке используйте shared-утилиты (`send_document_with_caption`, `send_transcript_error` в `services/transcript_utils.py`).
- Не дублируйте вызовы bot.send_document и bot.send_message в каждом хендлере.

## Централизация промтов для GPT

- Все промты для GPT (транскрибация, резюме, MoM, ToDo, протоколы и др.) должны храниться только в отдельном модуле, например, `frontend_bot/GPT_Prompts/transcribe/prompts.py`.
- В хендлерах и сервисах запрещено дублировать или захардкоживать промты — только импортировать из централизованного файла.
- Это облегчает поддержку, локализацию и переиспользование промтов.

## Источник истины: get_current_avatar_id

- Функция `get_current_avatar_id` должна импортироваться только из `frontend_bot/services/avatar_manager.py`.
- Дублирование или заглушки в других сервисах запрещены.
- Использование в хендлерах, валидаторах и сервисах — только через avatar_manager.
- Причина: avatar_manager хранит актуальное состояние avatar_id пользователя (in-memory).

## Валидация фото (размер, формат, дубликаты)

- Вся валидация фото (размер, формат, дубликаты) реализована только в функции `validate_photo` из `frontend_bot/services/avatar_manager.py`.
- Использование любых других функций для проверки фото запрещено.
- Все новые хендлеры и сервисы должны вызывать только эту функцию.
- Параметры валидации (минимальный размер, поддерживаемые форматы) берутся из config.

## Redis в архитектуре проекта

- Используется для хранения FSM-состояний пользователей, кэша и очередей задач.
- Персистентность Redis отключена (in-memory, потеря данных не критична).
- Все сервисы берут параметры подключения из переменных окружения (`REDIS_HOST`, `REDIS_PORT`).
- Для асинхронных компонентов используется `redis[async]`.
- Все операции с Redis инкапсулированы в отдельном модуле `shared/redis_client.py`.
- Не хранить в Redis критичные данные (только временные состояния, кэш, очереди).

### Схема взаимодействия

- FSM/сессии пользователей → Redis
- Очереди задач (например, на обработку аудио/аватаров) → Redis
- Кэш быстрых данных (например, лимиты, временные токены) → Redis

---

### Best practices
- Не использовать sync-клиенты Redis в async-коде.
- Все ключи — с префиксом проекта/модуля.
- TTL для временных данных.
- Ошибки Redis логировать, но не блокировать основной flow.
- Для тестов использовать отдельную БД или mock-Redis.

## Redis integration

- Используется redis-py (redis.asyncio) для асинхронного доступа к Redis.
- Весь код клиента — в shared/redis_client.py, глобальный экземпляр redis_client.
- Конфигурация через config.py и .env.
- Для unit-тестов — мок MagicMock/AsyncMock, для интеграционных — отдельный файл и mark.integration.
- FSM и кэш должны использовать только сервисные функции, прямой доступ к redis_client запрещён в хендлерах.
- Пример использования и мокирования — см. tests/shared/test_redis_client.py.

## Использование Redis

- Redis используется для хранения состояния FSM, кэша и очередей задач.
- Все интеграционные тесты используют реальный Redis, параметры подключения задаются через переменные окружения:
  - `REDIS_HOST`, `REDIS_PORT`, `REDIS_DB`, `REDIS_PASSWORD`
- Для pub/sub тестов реализован polling для стабильности.

**Пример .env для Redis:**
```
REDIS_HOST=192.168.0.3
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=<ваш_пароль>
```

## Тестирование с использованием Redis

- Для интеграционных тестов используется реальный сервер Redis (docker, локальный или внешний).
- Все параметры подключения задаются через переменные окружения (`REDIS_HOST`, `REDIS_PORT`, `REDIS_DB`, `REDIS_PASSWORD`).
- Для очистки данных между тестами используйте autouse-фикстуру с redis_client.delete_pattern("state:*").
- Все тесты должны быть изолированы: не влияют друг на друга, не используют глобальное состояние без фикстур.
- Для pub/sub и очередей используйте отдельные ключи с префиксом.

**Пример фикстуры для очистки Redis:**
```python
@pytest.fixture(autouse=True)
async def cleanup_redis():
    await redis_client.delete_pattern("state:*")
```

## Redis

### Общая информация
- Модуль: `frontend_bot/shared/redis_client.py`
- Использование: FSM, кэш, очереди, логи
- Конфигурация: переменные окружения

### Структура данных
- user:{user_id} - состояния пользователей
- cache:{key} - кэшированные данные
- queue:{name} - очереди задач
- log:{timestamp} - критические логи

### Интеграция
- Все операции через redis_client
- Запрет прямого доступа в хендлерах
- Отдельная БД для тестов
- Асинхронные операции

### Масштабирование
- Connection pooling
- TTL для автоматической очистки
- Шардирование по префиксам
- Репликация для отказоустойчивости

## Файловая система

### Общая информация
- Модуль: `frontend_bot/utils/file_manager.py`
- Директории: logs/, data/, temp/
- Игнорирование: archive/

### Структура
- logs/ - файлы логов
- data/ - постоянные данные
- temp/ - временные файлы
- archive/ - архивы (игнорируется)

### Интеграция
- Асинхронные операции
- Обработка ошибок
- Очистка временных файлов
- Бэкапы важных данных

### Масштабирование
- Буферизация операций
- Асинхронное чтение/запись
- Кэширование метаданных
- Компрессия больших файлов

## Логирование

### Общая информация
- Модуль: `frontend_bot/utils/advanced_logger.py`
- Конфигурация: `frontend_bot/config.py`
- Тесты: `frontend_bot/tests/utils/test_advanced_logger.py`

### Компоненты
1. JSONFormatter
   - Структурированное логирование
   - Включает timestamp, уровень, модуль
   - Поддержка контекста и исключений

2. RedisHandler
   - Хранение критических логов
   - TTL для автоматической очистки
   - Асинхронные операции

3. RotatingFileHandler
   - Ротация по размеру
   - Архивирование старых логов
   - Ограничение количества файлов

### Интеграция
- Все компоненты используют единый логгер
- Конфигурация через переменные окружения
- Отдельные логи для тестов
- Мониторинг через Prometheus

### Масштабирование
- Ротация предотвращает переполнение
- Redis для распределенного хранения
- Асинхронные операции не блокируют
- Graceful degradation при ошибках

## Файловая система

# История изменений и актуализация архитектуры

## Changelog (2024)

- **2024-05-16**
    - Исправлена настройка timezone для Alembic (используется IANA-таймзона, например, Asia/Tashkent).
    - Добавлен шаблон `migrations/script.py.mako` для корректной генерации миграций.
    - Все тесты PostgreSQL используют отдельную тестовую БД (`aisha_test`).
    - Исправлены async-тесты: используются только `AsyncMock` для асинхронных функций и объектов, корректно передаются аргументы.
    - Удалён устаревший файл `architecture.md` из корня — актуальная архитектура только в `docs/architecture.md`.
    - README.md должен ссылаться только на этот файл.

## Важно
- Все архитектурные решения, best practices и изменения фиксируются только в этом файле (`docs/architecture.md`).
- При изменениях архитектуры, переходах между состояниями, добавлении новых сервисов или тестов — обязательно обновлять этот файл.
