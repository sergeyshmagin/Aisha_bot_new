# Лучшие практики разработки

## 1. Общие принципы

### 1.1. Структура проекта
- Все сервисы в `frontend_bot/services/`
- Общие утилиты в `shared_storage/`
- Тесты в `tests/`
- Конфигурация в `config.py`
- Скрипты в `scripts/`
- Документация в `docs/`

### 1.2. Централизация компонентов
- Все шаблоны сообщений, caption, ошибки — только в `frontend_bot/texts/`
- Все генераторы клавиатур (inline/reply) — только в `frontend_bot/keyboards/`
- Все прогресс-бары и shared-утилиты — только в `frontend_bot/shared/`
- Не допускается дублирование шаблонов и клавиатур в хендлерах или сервисах

### 1.3. Код
- Следуйте PEP 8
- Используйте type hints
- Пишите docstrings для всех функций и классов
- Избегайте дублирования кода (DRY)
- Используйте константы вместо магических чисел
- Обрабатывайте все возможные исключения

### 1.4. Безопасность
- Никогда не храните секреты в коде
- Используйте переменные окружения для конфигурации
- Валидируйте все пользовательские входные данные
- Используйте безопасные методы хранения паролей
- Регулярно обновляйте зависимости

### 1.5. Утилиты и общие функции
- Размещайте общие утилиты в `shared/` директории
- Группируйте связанные утилиты в отдельные модули (например, `file_utils.py`, `image_utils.py`)
- Документируйте все параметры и возвращаемые значения
- Используйте type hints для всех функций
- Обрабатывайте все возможные исключения
- Пишите тесты для утилит
- Избегайте дублирования утилитарных функций
- Используйте единый стиль именования для утилит
- Следуйте принципу "один файл - одна группа утилит"
- Обновляйте импорты при перемещении функций
- Проверяйте все импорты после рефакторинга
- Используйте абсолютные импорты для утилит
- Документируйте зависимости между утилитами
- Следите за циклическими зависимостями

### 1.6. Ключи словарей и hashable-объекты
- Никогда не используйте list, dict, set в качестве ключей словаря или элементов set
- Для составных ключей используйте tuple или строку с разделителем (например, f"{user_id}:{avatar_id}")
- После рефакторинга структуры ключей выполните поиск по коду на предмет старых паттернов
- Добавляйте тесты, которые явно проверяют работу с ключами словарей

### 1.7. Хранение файлов и данных
- Все файлы (аудио, транскрипты, изображения, документы) должны храниться только в MinIO (или совместимом S3-хранилище).
- Все структурированные и бизнес-данные (пользователи, состояния, транзакции и т.д.) — только в PostgreSQL.
- Прямое хранение файлов на локальном диске запрещено (кроме временных файлов для обработки, которые затем удаляются).
- Использование других хранилищ допускается только при согласовании с архитектором и фиксации в docs/architecture.md.

## 2. Асинхронность

### 2.1. Основные принципы
- Все операции с файлами — только через `aiofiles` и асинхронные аналоги
- Внешние процессы (ffmpeg, docx) — только через `asyncio.create_subprocess_exec`
- Не использовать `open()`, `os.remove()`, `os.path.exists()` напрямую в async-коде
- **Все файлы должны храниться в MinIO, загрузка/выгрузка — только через сервисы-обёртки.**
- **Все бизнес-данные и состояния — только в PostgreSQL.**
- **Если появляется новая sync-функция, обязательно проверять, чтобы её не вызывали с await**

### 2.2. Строгое правило по await
- **Все вызовы асинхронных функций (coroutine) должны сопровождаться await**
- Запрещено вызывать async-функции без await — это приводит к ошибкам выполнения, предупреждениям RuntimeWarning и потере задач
- При code review обязательно проверять, что все вызовы async-функций имеют await
- Исключение: если coroutine передаётся как объект (например, в asyncio.create_task), но не вызывается напрямую

**Пример (правильно):**
```python
is_audio = await is_audio_file_ffmpeg(temp_file)
```

**Пример (ошибка!):**
```python
is_audio = is_audio_file_ffmpeg(temp_file)  # ОШИБКА: нет await
```

**Чеклист для code review:**
- [ ] Нет вызовов async-функций без await
- [ ] Нет RuntimeWarning: coroutine was never awaited
- [ ] Все асинхронные операции (файлы, процессы, HTTP) вызываются с await

## 3. Тестирование

### 3.1. Общие принципы тестирования
- Тесты должны быть независимыми и изолированными
- Каждый тест должен проверять одну конкретную функциональность
- Используйте фикстуры для подготовки тестового окружения
- Следуйте паттерну AAA (Arrange-Act-Assert)
- Поддерживайте тесты в актуальном состоянии

### 3.2. Моки и стабы
- Всегда мокайте внешние зависимости (API, базы данных, файловая система)
- Используйте `AsyncMock` для асинхронных функций
- Создавайте фикстуры для часто используемых моков
- Проверяйте вызовы моков с правильными параметрами
- Используйте `autouse=True` для глобальных моков (например, API клиентов)

### 3.3. Фикстуры
- Размещайте общие фикстуры в `conftest.py`
- Используйте `scope` для оптимизации выполнения тестов
- Создавайте фикстуры для тестовых данных
- Очищайте состояние после каждого теста
- Документируйте назначение фикстур

### 3.4. Асинхронное тестирование
- Используйте `pytest-asyncio` для асинхронных тестов
- Мокайте асинхронные контекстные менеджеры
- Используйте `AsyncMock` для асинхронных методов
- Проверяйте асинхронные вызовы с `await`
- Обрабатывайте асинхронные исключения

### 3.5. Изоляция тестов
- Каждый тест должен работать с изолированным окружением
- Очищайте состояние между тестами
- Используйте временные файлы и директории
- Мокайте системные вызовы
- Избегайте зависимостей между тестами

### 3.6. Покрытие кода
- Стремитесь к покрытию кода > 80%
- Тестируйте граничные случаи
- Проверяйте обработку ошибок
- Тестируйте асинхронные операции
- Включайте интеграционные тесты

### 3.7. Организация тестов
- Группируйте тесты по функциональности
- Используйте понятные имена тестов
- Документируйте тестовые сценарии
- Следуйте структуре проекта в тестах
- Используйте маркеры для категоризации тестов

### 3.8. Отладка тестов
- Используйте `pytest -v` для подробного вывода
- Включайте отладочные сообщения в тесты
- Проверяйте состояние моков
- Используйте `pdb` для отладки
- Логируйте важные операции

### 3.9. CI/CD
- Запускайте тесты в CI/CD пайплайне
- Проверяйте покрытие кода
- Используйте линтеры и форматтеры
- Автоматизируйте проверку типов
- Отслеживайте производительность тестов

### 3.10. Антипаттерны
- Избегайте тестов, зависящих от порядка выполнения
- Не используйте реальные API в тестах
- Не создавайте тесты, зависящие от времени
- Не используйте глобальное состояние
- Не игнорируйте ошибки в тестах

## 4. Работа с API

### 4.1. REST API
- Используйте семантическую версионизацию
- Документируйте все эндпоинты
- Используйте правильные HTTP методы
- Обрабатывайте ошибки с правильными кодами
- Используйте пагинацию для больших наборов данных

### 4.2. Аутентификация
- Используйте JWT для аутентификации
- Храните токены безопасно
- Реализуйте механизм обновления токенов
- Проверяйте права доступа
- Логируйте попытки доступа

### 4.3. Безопасность API
- Используйте HTTPS
- Валидируйте все входные данные
- Защищайте от CSRF атак
- Ограничивайте частоту запросов
- Мониторьте подозрительную активность

## 5. Работа с базой данных

### 5.1. Модели
- Все модели должны наследоваться от `Base` из `database.models`
- Использовать UUID или snowflake для id в моделях
- Все поля с датами должны иметь `created_at` и `updated_at`
- Использовать `relationship` для связей между моделями
- Все внешние ключи должны иметь `nullable=False`
- Использовать `JSON` тип для хранения метаданных

### 5.2. Запросы
- Используйте ORM для простых запросов
- Оптимизируйте сложные запросы
- Используйте транзакции
- Обрабатывайте ошибки БД
- Логируйте медленные запросы

## 6. Логирование

### 6.1. Общие принципы
- Используйте структурированное логирование
- Логируйте все важные операции
- Включайте контекст в логи
- Используйте разные уровни логирования
- Ротируйте логи

### 6.2. Мониторинг
- Настройте алерты
- Отслеживайте метрики
- Мониторьте производительность
- Логируйте ошибки
- Анализируйте логи

## 7. Документация

### 7.1. Код
- Документируйте все публичные API
- Используйте docstrings
- Включайте примеры использования
- Документируйте исключения
- Поддерживайте документацию в актуальном состоянии

### 7.2. API
- Документируйте все эндпоинты
- Включайте примеры запросов и ответов
- Описывайте параметры
- Документируйте ошибки
- Используйте OpenAPI/Swagger

### 7.3. Развертывание
- Документируйте процесс развертывания
- Включайте требования к окружению
- Описывайте конфигурацию
- Документируйте переменные окружения
- Включайте инструкции по устранению неполадок

## 8. Telegram Bot Best Practices

### 8.1. Обработка reply-кнопок
- Для reply-кнопок всегда используйте точное сравнение текста:
  ```python
  @bot.message_handler(func=lambda m: m.text == "Сводка на 1 страницу")
  async def send_short_summary(message):
      ...
  ```
- Не используйте фильтры вида `"mom" in m.text.lower()` или `func=lambda m: True` для reply-кнопок
- Для универсальных хендлеров используйте только явную фильтрацию по FSM-состоянию внутри функции
- Все catch-all хендлеры должны быть либо удалены, либо максимально ограничены

### 8.2. Централизация бота
- Объект `bot` должен создаваться только в одном месте (например, в `frontend_bot/bot_instance.py`)
- Во всех хендлерах импортируйте bot только из этого файла
- Не создавайте bot локально в каждом модуле
- Все хендлеры должны импортироваться в точке входа
- Запускать polling только на этом экземпляре bot

### 8.3. Примеры правильной регистрации
```python
@bot.message_handler(func=lambda m: m.text == "Сформировать MoM")
async def send_mom(message):
    ...
```

### 8.4. Примеры неправильной регистрации (НЕ ДЕЛАТЬ)
```python
@bot.message_handler(func=lambda m: "mom" in m.text.lower())
async def send_mom(message):
    ...
```

## 9. Приоритеты рефакторинга

### 9.1. Критичные нарушения
```python
# services/transcribe.py (line 45)
with open(temp_file, 'rb') as f:  # Нарушение: синхронное чтение

# handlers/avatar.py (line 31)
os.remove(temp_path)  # Нарушение: синхронное удаление
```

### 9.2. План исправлений
1. **Унификация файловых операций**  
Создать `shared/file_operations.py` с async-менеджером:
```python
class AsyncFileManager:
    @staticmethod
    async def safe_remove(path: Path) -> None:
        try:
            await aiofiles.os.remove(str(path))
        except FileNotFoundError:
            logger.warning(f"File {path} not found")
```

2. **Тестирование асинхронности**  
Добавить интеграционные тесты:
```python
async def test_async_remove():
    test_file = Path("test.tmp")
    test_file.touch()
    await AsyncFileManager.safe_remove(test_file)
    assert not await aiofiles.os.path.exists(test_file)
```

### 9.3. Этапы рефакторинга
| Этап           | Срок   | Связь с практиками      |
|----------------|--------|-------------------------|
| Рефакторинг IO | 1 нед  | §2.1, §5.1              |
| Тесты безопасности | 3 дня | §3.1, §5.2          |

## 10. Примеры использования

- Примеры запуска, настройки и расширения — в `README.md` и `docs/quickstart.md`
- Примеры добавления новых shared-компонентов — в этом файле
- Все задачи, планы и чек-листы ведём только в корневом TASK.md
- Архитектура и best practices — только в docs/architecture.md, docs/best_practices.md
- Не допускается дублирование задач и регламентов в других файлах
- Все новые правила и процессы — отдельный подраздел в best_practices.md
- Любое изменение в архитектуре или процессах — фиксировать в соответствующем md-файле
- В README.md — только краткое описание и ссылки на docs/ 

# Лучшие практики работы с БД и MinIO

## 1. Работа с PostgreSQL

### Модели и миграции
- Все модели должны наследоваться от `Base` из `database.models`
- Использовать UUID или snowflake для id в моделях
- Все поля с датами должны иметь `created_at` и `updated_at`
- Использовать `relationship` для связей между моделями
- Все внешние ключи должны иметь `nullable=False`
- Использовать `JSON` тип для хранения метаданных

### Сессии и транзакции
- Использовать контекстный менеджер для сессий:
```python
async with AsyncSessionLocal() as session:
    async with session.begin():
        # операции с БД
```

- Для асинхронных операций использовать `database_sync_to_async`
- Все операции с БД должны быть в транзакциях
- Использовать `select_related` и `joinedload` для оптимизации запросов

### Безопасность
- Все параметры подключения через переменные окружения
- Использовать параметризованные запросы
- Не хранить секреты в коде
- Использовать миграции для изменения схемы

## 2. Работа с MinIO

### Структура bucket'ов
```
avatars/
  {user_id}/
    {avatar_id}/
      original.png
      processed.webp
      metadata.json

transcripts/
  {user_id}/
    {session_id}/
      original.mp3
      transcript.txt
      summary.json

documents/
  {user_id}/
    {doc_id}/
      protocol.docx
      protocol.pdf

temp/
  {user_id}/
    {timestamp}/
      ...
```

### Политики хранения
- avatars/, documents/ — бессрочно
- transcripts/ — автоудаление через 30–90 дней
- temp/ — автоудаление через 1–3 дня

### Операции с файлами
- Использовать асинхронные методы
- Обрабатывать ошибки
- Проверять существование файлов
- Очищать временные файлы

### Presigned URL
- Ограничивать время жизни URL
- Проверять IP-адреса
- Логировать доступ
- Отзывать при необходимости

## 3. Асинхронное программирование

### Общие принципы
- Использовать `async/await` для всех I/O операций
- Не блокировать event loop
- Использовать `asyncio.gather` для параллельных операций
- Обрабатывать исключения в асинхронном коде

### Работа с БД
```python
from database.config import get_async_db

async def some_operation():
    async with get_async_db() as session:
        async with session.begin():
            # операции с БД
```

### Работа с файлами
```python
from storage_utils import upload_file, generate_presigned_url

async def handle_file(file_data: bytes):
    # Загрузка файла
    await upload_file("bucket", "key", file_data)
    
    # Генерация URL для доступа
    url = await generate_presigned_url("bucket", "key")
```

## 4. Тестирование

### Тесты БД
- Использовать тестовую БД в памяти
- Создавать фикстуры для тестовых данных
- Очищать БД после каждого теста
- Тестировать транзакции и откаты

### Тесты MinIO
- Использовать тестовый bucket
- Мокать MinIO клиент
- Тестировать загрузку и скачивание
- Проверять политики хранения

### Интеграционные тесты
- Тестировать взаимодействие БД и MinIO
- Проверять транзакции
- Тестировать обработку ошибок
- Проверять асинхронные операции

## 5. Мониторинг и логирование

### Метрики
- Отслеживать использование диска
- Мониторить количество запросов
- Измерять время ответа
- Собирать статистику

### Алерты
- Настроить уведомления
- Определить пороги
- Настроить эскалацию
- Вести журнал

## 6. Безопасность

### БД
- Использовать SSL для подключения
- Ограничивать доступ по IP
- Регулярно обновлять пароли
- Делать бэкапы

### MinIO
- Использовать SSL
- Настраивать CORS
- Ограничивать доступ
- Шифровать данные

## 7. Оптимизация

### Производительность
- Использовать кэширование
- Оптимизировать запросы
- Сжимать данные
- Балансировать нагрузку

### Хранение
- Очищать старые файлы
- Архивировать данные
- Оптимизировать индексы
- Мониторить рост

## 8. Миграция данных

### Подготовка
- Создать бэкап данных
- Проверить доступ к MinIO
- Настроить bucket'ы
- Подготовить скрипты

### Процесс
- Мигрировать данные пакетами
- Проверять целостность
- Логировать процесс
- Обрабатывать ошибки

### Проверка
- Сверять количество файлов
- Проверять метаданные
- Тестировать доступ
- Валидировать данные

## 9. Документация

### Код
- Документировать функции
- Описывать параметры
- Приводить примеры
- Обновлять при изменениях

### API
- Описывать эндпоинты
- Документировать форматы
- Приводить примеры
- Указывать ограничения

### Развертывание
- Описывать требования
- Указывать зависимости
- Приводить команды
- Документировать конфигурацию 

### Best practices для тестового окружения и шаблон .env.test

- Для тестов всегда использовать отдельный файл `.env.test` с тестовыми значениями.
- Никогда не использовать боевые ключи, токены и пароли в тестах и CI/CD.
- Для интеграционных тестов MinIO, Redis, Postgres используются реальные тестовые сервисы:
  - MinIO: 192.168.0.4:9000, бакет `test-bucket`
  - Redis: 192.168.0.3:6379, отдельная тестовая БД
  - Postgres: 192.168.0.4:5432, отдельная тестовая БД
- Для unit-тестов SQL — только SQLite in-memory (`TEST_DATABASE_URL=sqlite+aiosqlite:///:memory:`)
- Все тестовые переменные должны быть заданы явно через `.env.test` или переменные окружения CI/CD.
- Любой тест, использующий боевые ключи — блокируется к запуску.

#### Пример шаблона `.env.test`:

```env
TELEGRAM_TOKEN=test_token
BACKEND_URL=http://localhost:8000
OPENAI_API_KEY=test_key
ASSISTAND_ID=test_assistant
OPENAI_EMAIL=test@example.com
OPENAI_PASSWORD=test_password
ASTRIA_API_KEY=test_astria
POSTGRES_DSN=postgresql://test_user:test_password@192.168.0.4:5432/test_db
FAL_KEY=test_fal_key
FAL_TRAINING_TEST_MODE=true

PYTHONPATH=.

# Redis (тестовый сервер)
REDIS_HOST=192.168.0.3
REDIS_PORT=6379
REDIS_DB=1
REDIS_PASSWORD=
REDIS_SSL=false
REDIS_POOL_SIZE=10
REDIS_POOL_TIMEOUT=5
REDIS_RETRY_ON_TIMEOUT=true
REDIS_MAX_RETRIES=3
REDIS_RETRY_INTERVAL=1

# PostgreSQL (тестовый сервер)
POSTGRES_HOST=192.168.0.4
POSTGRES_PORT=5432
POSTGRES_DB=test_db
POSTGRES_USER=test_user
POSTGRES_PASSWORD=test_password
DATABASE_URL=postgresql+asyncpg://test_user:test_password@192.168.0.4:5432/test_db

# SQLite (unit-тесты)
TEST_DATABASE_URL=sqlite+aiosqlite:///:memory:

# MinIO (тестовый сервер)
MINIO_ENDPOINT=192.168.0.4:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET=test-bucket
``` 

- Для интеграционных тестов Redis:
  - Использовать отдельную тестовую БД (`REDIS_DB=1`), сервер 192.168.0.3:6379.
  - После каждого теста очищать БД через flushdb.
  - Для unit-тестов — использовать mock Redis, не подключаясь к реальному серверу.
- Для интеграционных тестов Postgres:
  - Использовать отдельную тестовую БД (`test_db`), отдельного пользователя (`test_user`), сервер 192.168.0.4:5432.
  - После тестов очищать БД или использовать транзакции с откатом.
  - Для unit-тестов — только SQLite in-memory. 

> **Все модели БД определяются только в `database/models.py`. Импорты моделей — только `from database.models import ...`. Дублирующих моделей в других папках быть не должно. После любого рефакторинга моделей — проверить и обновить все импорты по проекту.**

### Очистка временных данных пользователя

- Для отмены создания аватара или других временных операций используйте сервисную функцию `cleanup_state(user_id: int)`.
- Функция должна:
  - Сбрасывать FSM-состояние пользователя (`set_state_pg`).
  - Удалять черновики/временные записи из БД (если есть).
  - Удалять временные файлы из MinIO (если workflow их создаёт).
- Импорты и вызовы cleanup_state должны быть только из сервисного слоя.

### Черновики аватара (draft)

- Черновик аватара всегда хранится в БД (`user_avatars.is_draft=1`) на протяжении всего визарда.
- На каждом шаге визарда обновляйте данные черновика.
- После завершения визарда переводите черновик в финальный статус (`is_draft=0`).
- При отмене визарда или очистке состояния — удаляйте черновик.
- Не допускайте более одного черновика на пользователя одновременно.

### Production: подключение к основной БД

```env
POSTGRES_DB=aisha
POSTGRES_USER=aisha_user
POSTGRES_PASSWORD=KbZZGJHX09KSH7r9ev4m
POSTGRES_HOST=192.168.0.4
POSTGRES_PORT=5432
DATABASE_URL=postgresql+asyncpg://aisha_user:KbZZGJHX09KSH7r9ev4m@192.168.0.4:5432/aisha
```

- Основная рабочая база данных — `aisha`. Все миграции и боевые данные хранятся только в ней.
- Для тестов используйте отдельную БД или SQLite in-memory.

## Работа с user_id
- Для всех операций с транскриптами, историей, балансом и состояниями пользователя в базе данных всегда используйте UUID пользователя (`user.id`), а не Telegram ID.
- Telegram ID используется только для поиска пользователя в базе (`get_by_telegram_id`).
- Любые сервисы, работающие с user_id, должны принимать UUID.

## Транскрипты: только MinIO и кэш
- Всегда сохраняйте и читайте транскрипты только через MinIO и кэш user_transcript_cache.
- Не используйте локальные файлы для бизнес-логики (только для временных операций).
- Все сервисы должны работать с MinIO-ключами, а не с путями на диске.
- Для получения текста транскрипта используйте download_file(bucket, minio_key).

## Бизнес-ассистент: типовые ошибки и чек-лист
- Не использовать локальные файлы для транскриптов (только MinIO и кэш user_transcript_cache)
- Всегда использовать UUID пользователя для всех операций с транскриптами, историей, балансом и состояниями
- Telegram ID — только для поиска пользователя в базе
- Все сервисы и хендлеры должны работать с MinIO-ключами, а не с путями на диске
- Для получения текста транскрипта использовать только download_file(bucket, minio_key)
- Все файловые операции — только через aiofiles (async)
- Внешние процессы — только через asyncio.create_subprocess_exec
- Не использовать sync-функции (open, os.path, shutil) в async-коде
- Порядок регистрации хендлеров: сначала специфичные, потом универсальные
- Исключения всегда логировать через logger.exception, пользователю отправлять информативные сообщения
- Все новые публичные функции и классы — с docstring и аннотациями типов
- Покрывать новый код unit-тестами (pytest, pytest-asyncio)
- Проверять, что все тесты зелёные после изменений
- Все архитектурные решения и best practices фиксировать в docs/

### Чек-лист для ревью бизнес-ассистента
- [ ] Нет sync-операций с файлами в async-коде
- [ ] Все транскрипты только в MinIO, кэш — user_transcript_cache
- [ ] Все user_id — UUID, Telegram ID только для поиска
- [ ] Все сервисы работают с MinIO-ключами
- [ ] Все ошибки логируются и информируют пользователя
- [ ] Все хендлеры зарегистрированы в правильном порядке
- [ ] Покрытие тестами ≥ 80%
- [ ] Документация и best practices обновлены

## Работа с состоянием (FSM)

### Общие правила
1. Все функции работы с состоянием (`set_state`, `get_state`, `clear_state`) **обязательно** должны получать `session` как параметр.
2. Не использовать глобальные переменные для хранения состояния.
3. Все состояния должны храниться в PostgreSQL через `StateRepository`.

### Примеры правильного использования
```python
# Правильно:
async def handle_state(message, session):
    await set_state(user_id, "new_state", session)
    state = await get_state(user_id, session)
    await clear_state(user_id, session)

# Неправильно:
async def handle_state(message):  # ❌ Нет session
    await set_state(user_id, "new_state")  # ❌ Нет session
```

### Типовые ошибки
1. ❌ Вызов `set_state` без `session`
2. ❌ Использование глобальных переменных для состояния
3. ❌ Хранение состояния в памяти
4. ❌ Отсутствие обработки ошибок при работе с БД

### Рекомендации
1. Всегда передавайте `session` в функции работы с состоянием
2. Используйте транзакции для атомарных операций
3. Логируйте все изменения состояния
4. Обрабатывайте ошибки БД
5. Используйте типизацию для `session` (AsyncSession)

## Работа с аватарами (галерея, фото)

- Все фото и состояния аватаров — только через PostgreSQL и MinIO
- Нет локальных файлов, json, sync-операций
- Для получения фото используйте:

```python
photos = await get_avatar_photos_from_db(user_id, avatar_id, session)
```

- Для сохранения фото используйте только асинхронные сервисы:

```python
await save_avatar_minio(db=session, user_id=user_id, avatar_id=avatar_id, original=photo_bytes, metadata={...})
```

- Для предпросмотра и галереи — только выборка из user_avatar_photos и скачивание из MinIO

- Все операции с состоянием — только через сервисы и репозитории, sync-функции запрещены

## Централизация работы с MinIO

- Все сервисы и хендлеры используют только функции из `frontend_bot/services/minio_client.py` для работы с MinIO.
- Прямое создание Minio-клиента (`Minio(...)`) и импорты из других модулей (например, shared_storage.storage_utils) запрещены.
- В тестах допускается прямой клиент или мок.
- Это обеспечивает единый интерфейс, асинхронность и простоту поддержки.

### Best practices: работа с MinIO

- Используйте только функции и клиент из `frontend_bot/services/minio_client.py`.
- Не создавайте клиентов Minio напрямую в сервисах и обработчиках.
- Все вспомогательные функции для работы с MinIO (инициализация бакетов, генерация путей, presigned URL) должны быть реализованы в этом модуле.
- При необходимости расширения логики — добавляйте новые функции только в этот модуль.

- Не используйте `shared_storage/storage_utils.py` — этот файл удалён как legacy.
- Все операции с MinIO (upload, download, delete, presigned URL) — только через `frontend_bot/services/minio_client.py`.

- Используйте только новую унифицированную галерею для аватаров (handlers/avatar/gallery.py).
- Не создавайте дублирующие клавиатуры и обработчики для галереи — все расширения и изменения только через новую функцию и клавиатуру.
- Для новых сценариев добавляйте кнопки и логику только в новую реализацию.
- Подписи к фото (caption) всегда формируйте через get_gallery_caption.