# Лучшие практики разработки

## 1. Общие принципы

### 1.1. Структура проекта
- Используйте модульную структуру с четким разделением ответственности
- Следуйте принципу "один файл - одна ответственность"
- Максимальный размер файла - 500 строк
- Документируйте все публичные API и интерфейсы
- Размещайте общие утилиты в `shared/` директории
- Избегайте дублирования утилитарных функций

### 1.2. Централизация компонентов
- Все шаблоны сообщений, caption, ошибки — только в `frontend_bot/texts/`
- Все генераторы клавиатур (inline/reply) — только в `frontend_bot/keyboards/`
- Все прогресс-бары и shared-утилиты — только в `frontend_bot/shared/`
- Не допускается дублирование шаблонов и клавиатур в хендлерах или сервисах

### 1.3. Код
- Следуйте PEP 8
- Используйте type hints
- Пишите docstrings для всех функций и классов
- Избегайте дублирования кода (DRY)
- Используйте константы вместо магических чисел
- Обрабатывайте все возможные исключения

### 1.4. Безопасность
- Никогда не храните секреты в коде
- Используйте переменные окружения для конфигурации
- Валидируйте все пользовательские входные данные
- Используйте безопасные методы хранения паролей
- Регулярно обновляйте зависимости

### 1.5. Утилиты и общие функции
- Размещайте общие утилиты в `shared/` директории
- Группируйте связанные утилиты в отдельные модули (например, `file_utils.py`, `image_utils.py`)
- Документируйте все параметры и возвращаемые значения
- Используйте type hints для всех функций
- Обрабатывайте все возможные исключения
- Пишите тесты для утилит
- Избегайте дублирования утилитарных функций
- Используйте единый стиль именования для утилит
- Следуйте принципу "один файл - одна группа утилит"
- Обновляйте импорты при перемещении функций
- Проверяйте все импорты после рефакторинга
- Используйте абсолютные импорты для утилит
- Документируйте зависимости между утилитами
- Следите за циклическими зависимостями

### 1.6. Ключи словарей и hashable-объекты
- Никогда не используйте list, dict, set в качестве ключей словаря или элементов set
- Для составных ключей используйте tuple или строку с разделителем (например, f"{user_id}:{avatar_id}")
- После рефакторинга структуры ключей выполните поиск по коду на предмет старых паттернов
- Добавляйте тесты, которые явно проверяют работу с ключами словарей

## 2. Асинхронность

### 2.1. Основные принципы
- Все операции с файлами — только через `aiofiles` и асинхронные аналоги
- Внешние процессы (ffmpeg, docx) — только через `asyncio.create_subprocess_exec`
- Не использовать `open()`, `os.remove()`, `os.path.exists()` напрямую в async-коде
- **Если появляется новая sync-функция, обязательно проверять, чтобы её не вызывали с await**

### 2.2. Строгое правило по await
- **Все вызовы асинхронных функций (coroutine) должны сопровождаться await**
- Запрещено вызывать async-функции без await — это приводит к ошибкам выполнения, предупреждениям RuntimeWarning и потере задач
- При code review обязательно проверять, что все вызовы async-функций имеют await
- Исключение: если coroutine передаётся как объект (например, в asyncio.create_task), но не вызывается напрямую

**Пример (правильно):**
```python
is_audio = await is_audio_file_ffmpeg(temp_file)
```

**Пример (ошибка!):**
```python
is_audio = is_audio_file_ffmpeg(temp_file)  # ОШИБКА: нет await
```

**Чеклист для code review:**
- [ ] Нет вызовов async-функций без await
- [ ] Нет RuntimeWarning: coroutine was never awaited
- [ ] Все асинхронные операции (файлы, процессы, HTTP) вызываются с await

## 3. Тестирование

### 3.1. Общие принципы тестирования
- Тесты должны быть независимыми и изолированными
- Каждый тест должен проверять одну конкретную функциональность
- Используйте фикстуры для подготовки тестового окружения
- Следуйте паттерну AAA (Arrange-Act-Assert)
- Поддерживайте тесты в актуальном состоянии

### 3.2. Моки и стабы
- Всегда мокайте внешние зависимости (API, базы данных, файловая система)
- Используйте `AsyncMock` для асинхронных функций
- Создавайте фикстуры для часто используемых моков
- Проверяйте вызовы моков с правильными параметрами
- Используйте `autouse=True` для глобальных моков (например, API клиентов)

### 3.3. Фикстуры
- Размещайте общие фикстуры в `conftest.py`
- Используйте `scope` для оптимизации выполнения тестов
- Создавайте фикстуры для тестовых данных
- Очищайте состояние после каждого теста
- Документируйте назначение фикстур

### 3.4. Асинхронное тестирование
- Используйте `pytest-asyncio` для асинхронных тестов
- Мокайте асинхронные контекстные менеджеры
- Используйте `AsyncMock` для асинхронных методов
- Проверяйте асинхронные вызовы с `await`
- Обрабатывайте асинхронные исключения

### 3.5. Изоляция тестов
- Каждый тест должен работать с изолированным окружением
- Очищайте состояние между тестами
- Используйте временные файлы и директории
- Мокайте системные вызовы
- Избегайте зависимостей между тестами

### 3.6. Покрытие кода
- Стремитесь к покрытию кода > 80%
- Тестируйте граничные случаи
- Проверяйте обработку ошибок
- Тестируйте асинхронные операции
- Включайте интеграционные тесты

### 3.7. Организация тестов
- Группируйте тесты по функциональности
- Используйте понятные имена тестов
- Документируйте тестовые сценарии
- Следуйте структуре проекта в тестах
- Используйте маркеры для категоризации тестов

### 3.8. Отладка тестов
- Используйте `pytest -v` для подробного вывода
- Включайте отладочные сообщения в тесты
- Проверяйте состояние моков
- Используйте `pdb` для отладки
- Логируйте важные операции

### 3.9. CI/CD
- Запускайте тесты в CI/CD пайплайне
- Проверяйте покрытие кода
- Используйте линтеры и форматтеры
- Автоматизируйте проверку типов
- Отслеживайте производительность тестов

### 3.10. Антипаттерны
- Избегайте тестов, зависящих от порядка выполнения
- Не используйте реальные API в тестах
- Не создавайте тесты, зависящие от времени
- Не используйте глобальное состояние
- Не игнорируйте ошибки в тестах

## 4. Работа с API

### 4.1. REST API
- Используйте семантическую версионизацию
- Документируйте все эндпоинты
- Используйте правильные HTTP методы
- Обрабатывайте ошибки с правильными кодами
- Используйте пагинацию для больших наборов данных

### 4.2. Аутентификация
- Используйте JWT для аутентификации
- Храните токены безопасно
- Реализуйте механизм обновления токенов
- Проверяйте права доступа
- Логируйте попытки доступа

### 4.3. Безопасность API
- Используйте HTTPS
- Валидируйте все входные данные
- Защищайте от CSRF атак
- Ограничивайте частоту запросов
- Мониторьте подозрительную активность

## 5. Работа с базой данных

### 5.1. Модели
- Используйте миграции для изменений схемы
- Индексируйте часто используемые поля
- Используйте внешние ключи
- Валидируйте данные на уровне БД
- Оптимизируйте запросы

### 5.2. Запросы
- Используйте ORM для простых запросов
- Оптимизируйте сложные запросы
- Используйте транзакции
- Обрабатывайте ошибки БД
- Логируйте медленные запросы

## 6. Логирование

### 6.1. Общие принципы
- Используйте структурированное логирование
- Логируйте все важные операции
- Включайте контекст в логи
- Используйте разные уровни логирования
- Ротируйте логи

### 6.2. Мониторинг
- Настройте алерты
- Отслеживайте метрики
- Мониторьте производительность
- Логируйте ошибки
- Анализируйте логи

## 7. Документация

### 7.1. Код
- Документируйте все публичные API
- Используйте docstrings
- Включайте примеры использования
- Документируйте исключения
- Поддерживайте документацию в актуальном состоянии

### 7.2. API
- Документируйте все эндпоинты
- Включайте примеры запросов и ответов
- Описывайте параметры
- Документируйте ошибки
- Используйте OpenAPI/Swagger

### 7.3. Развертывание
- Документируйте процесс развертывания
- Включайте требования к окружению
- Описывайте конфигурацию
- Документируйте переменные окружения
- Включайте инструкции по устранению неполадок

## 8. Telegram Bot Best Practices

### 8.1. Обработка reply-кнопок
- Для reply-кнопок всегда используйте точное сравнение текста:
  ```python
  @bot.message_handler(func=lambda m: m.text == "Сводка на 1 страницу")
  async def send_short_summary(message):
      ...
  ```
- Не используйте фильтры вида `"mom" in m.text.lower()` или `func=lambda m: True` для reply-кнопок
- Для универсальных хендлеров используйте только явную фильтрацию по FSM-состоянию внутри функции
- Все catch-all хендлеры должны быть либо удалены, либо максимально ограничены

### 8.2. Централизация бота
- Объект `bot` должен создаваться только в одном месте (например, в `frontend_bot/bot_instance.py`)
- Во всех хендлерах импортируйте bot только из этого файла
- Не создавайте bot локально в каждом модуле
- Все хендлеры должны импортироваться в точке входа
- Запускать polling только на этом экземпляре bot

### 8.3. Примеры правильной регистрации
```python
@bot.message_handler(func=lambda m: m.text == "Сформировать MoM")
async def send_mom(message):
    ...
```

### 8.4. Примеры неправильной регистрации (НЕ ДЕЛАТЬ)
```python
@bot.message_handler(func=lambda m: "mom" in m.text.lower())
async def send_mom(message):
    ...
```

## 9. Приоритеты рефакторинга

### 9.1. Критичные нарушения
```python
# services/transcribe.py (line 45)
with open(temp_file, 'rb') as f:  # Нарушение: синхронное чтение

# handlers/avatar.py (line 31)
os.remove(temp_path)  # Нарушение: синхронное удаление
```

### 9.2. План исправлений
1. **Унификация файловых операций**  
Создать `shared/file_operations.py` с async-менеджером:
```python
class AsyncFileManager:
    @staticmethod
    async def safe_remove(path: Path) -> None:
        try:
            await aiofiles.os.remove(str(path))
        except FileNotFoundError:
            logger.warning(f"File {path} not found")
```

2. **Тестирование асинхронности**  
Добавить интеграционные тесты:
```python
async def test_async_remove():
    test_file = Path("test.tmp")
    test_file.touch()
    await AsyncFileManager.safe_remove(test_file)
    assert not await aiofiles.os.path.exists(test_file)
```

### 9.3. Этапы рефакторинга
| Этап           | Срок   | Связь с практиками      |
|----------------|--------|-------------------------|
| Рефакторинг IO | 1 нед  | §2.1, §5.1              |
| Тесты безопасности | 3 дня | §3.1, §5.2          |

## 10. Примеры использования

- Примеры запуска, настройки и расширения — в `README.md` и `docs/quickstart.md`
- Примеры добавления новых shared-компонентов — в этом файле
- Все задачи, планы и чек-листы ведём только в корневом TASK.md
- Архитектура и best practices — только в docs/architecture.md, docs/best_practices.md
- Не допускается дублирование задач и регламентов в других файлах
- Все новые правила и процессы — отдельный подраздел в best_practices.md
- Любое изменение в архитектуре или процессах — фиксировать в соответствующем md-файле
- В README.md — только краткое описание и ссылки на docs/ 