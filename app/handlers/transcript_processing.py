"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞–º–∏.
–°–æ–¥–µ—Ä–∂–∏—Ç –º–µ—Ç–æ–¥—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—É–¥–∏–æ, —Ç–µ–∫—Å—Ç–∞ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤.
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å TranscriptService (MinIO + –ë–î).
"""
import logging
from datetime import datetime
from typing import Dict, Optional, Any, Union
from io import BytesIO
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.filters import StateFilter
from uuid import UUID
from pydantic import BaseModel, Field

from app.core.config import settings
from app.handlers.transcript_base import TranscriptBaseHandler
from app.core.di import (
    get_audio_processing_service,
    get_text_processing_service,
    get_transcript_service,
    get_user_service_with_session,
)
from app.keyboards.transcript import (
    get_transcript_actions_keyboard,
    get_back_to_transcript_keyboard,
    get_back_to_menu_keyboard,
)
from app.utils.uuid_utils import safe_uuid
from app.handlers.state import TranscribeStates

logger = logging.getLogger(__name__)

class TranscriptResult(BaseModel):
    """–ú–æ–¥–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞"""
    id: str = Field(..., description="–£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
    transcript_key: str = Field(..., description="–ö–ª—é—á –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç—É –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")

class TranscriptProcessingHandler(TranscriptBaseHandler):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤.
    –°–æ–¥–µ—Ä–∂–∏—Ç –º–µ—Ç–æ–¥—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤.
    –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å TranscriptService (MinIO + –ë–î).
    """
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤"""
        super().__init__()
        self.router = Router()
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω TranscriptProcessingHandler")

    async def register_handlers(self):
        """
        –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –¥–ª—è:
        - –û–±—Ä–∞–±–æ—Ç–∫–∏ –∞—É–¥–∏–æ
        - –û–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞
        - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
        - –î–µ–π—Å—Ç–≤–∏–π —Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–º
        """
        logger.info("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤")
        
        # –í–ê–ñ–ù–û: –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –†–ê–ù–¨–®–ï —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö!
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ (—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è - —Ç–æ–ª—å–∫–æ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ waiting_text)
        self.router.message.register(
            self._handle_text_processing,
            F.document & F.document.mime_type.in_(["text/plain"]),
            StateFilter(TranscribeStates.waiting_text)
        )
        
        # –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∞—É–¥–∏–æ (—Ä–∞–±–æ—Ç–∞—é—Ç –≤ –ª—é–±–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏)
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ü–û–°–õ–ï —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.router.message.register(
            self._handle_audio_universal,
            F.audio
        )
        
        self.router.message.register(
            self._handle_audio_universal,
            F.voice
        )
        
        # –ù–û–í–û–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ —Ñ–∞–π–ª–æ–≤, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç—ã
        # –ü—Ä–∏–Ω–∏–º–∞–µ–º –ª—é–±—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –≤–Ω—É—Ç—Ä–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
        self.router.message.register(
            self._handle_audio_document,
            F.document
        )
        
        # –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ callback'–æ–≤
        self.router.callback_query.register(
            self._handle_transcript_format,
            F.data.startswith("transcript_format_")
        )
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π —Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞–º–∏ (summary, todo, protocol)
        self.router.callback_query.register(
            self._handle_transcript_actions,
            F.data.startswith("transcript_summary_") | 
            F.data.startswith("transcript_todo_") | 
            F.data.startswith("transcript_protocol_")
        )
        
        self.router.callback_query.register(
            self._handle_back_to_transcribe_menu,
            F.data == "transcribe_back_to_menu"
        )

    async def _handle_audio_universal(self, message: Message, state: FSMContext) -> None:
        """
        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—É–¥–∏–æ –∏ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.
        –†–∞–±–æ—Ç–∞–µ—Ç –≤ –ª—é–±–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É.
        
        Args:
            message: –í—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∞—É–¥–∏–æ
            state: –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
        """
        current_state = await state.get_state()
        logger.info(f"[AUDIO_UNIVERSAL] –ü–æ–ª—É—á–µ–Ω–æ –∞—É–¥–∏–æ/voice –æ—Ç user_id={message.from_user.id}, current_state={current_state}")
        
        # –ï—Å–ª–∏ —É–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if current_state in [TranscribeStates.processing, TranscribeStates.result]:
            logger.info(f"[AUDIO_UNIVERSAL] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
            return
            
        # –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
        logger.info(f"[AUDIO_UNIVERSAL] –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∞—É–¥–∏–æ")
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∞—É–¥–∏–æ –Ω–∞–ø—Ä—è–º—É—é
        try:
            processing_msg = await message.answer("üéµ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∞—É–¥–∏–æ...")
            await state.set_state(TranscribeStates.processing)

            # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
            if message.voice:
                file_id = message.voice.file_id
                duration = message.voice.duration
                file_name = f"voice_{message.message_id}.ogg"
                file_size = message.voice.file_size
            else:
                file_id = message.audio.file_id  
                duration = message.audio.duration
                file_name = message.audio.file_name or f"audio_{message.message_id}.mp3"
                file_size = message.audio.file_size
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏)
            max_file_size = settings.MAX_AUDIO_SIZE  # 1GB
            telegram_api_limit = settings.TELEGRAM_API_LIMIT  # 20MB - –ª–∏–º–∏—Ç Telegram Bot API –¥–ª—è get_file()
            
            if file_size and file_size > max_file_size:
                logger.warning(f"[AUDIO_UNIVERSAL] –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π: {file_size} –±–∞–π—Ç (–ª–∏–º–∏—Ç: {max_file_size})")
                await message.reply(
                    f"‚ùå **–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π**\n\n"
                    f"–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {file_size / (1024*1024):.1f} –ú–ë\n"
                    f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: {max_file_size / (1024*1024*1024)} –ì–ë\n\n"
                    f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –º–µ–Ω—å—à–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞.",
                    parse_mode="Markdown"
                )
                await state.set_state(TranscribeStates.error)
                return
            
            # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
            if file_size and file_size > telegram_api_limit:
                logger.info(f"[AUDIO_UNIVERSAL] –ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª ({file_size} –±–∞–π—Ç), –ø—ã—Ç–∞–µ–º—Å—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–ø—ã—Ç–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
                await processing_msg.edit_text(
                    f"üìÅ **–ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª –æ–±–Ω–∞—Ä—É–∂–µ–Ω**\n\n"
                    f"üìä –†–∞–∑–º–µ—Ä: {file_size / (1024*1024):.1f} –ú–ë\n"
                    f"üìè –õ–∏–º–∏—Ç Bot API: {telegram_api_limit / (1024*1024):.0f} –ú–ë\n\n"
                    f"üîÑ **–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–º –º–µ—Ç–æ–¥–æ–º...**\n"
                    f"‚è≥ –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏",
                    parse_mode="Markdown"
                )
                
                # –ü—ã—Ç–∞–µ–º—Å—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –±–æ–ª—å—à–æ–π —Ñ–∞–π–ª —á–µ—Ä–µ–∑ chunked processing
                try:
                    from app.services.large_audio_processor import try_process_large_audio
                    
                    # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –±–æ—Ç–∞
                    bot_token = message.bot.token
                    
                    # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å file_path (–º–æ–∂–µ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞—Ç—å –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤)
                    file_path = None
                    try:
                        file = await message.bot.get_file(file_id)
                        file_path = file.file_path
                        logger.info(f"[AUDIO_UNIVERSAL] –ü–æ–ª—É—á–µ–Ω file_path –¥–ª—è –±–æ–ª—å—à–æ–≥–æ —Ñ–∞–π–ª–∞")
                    except Exception as e:
                        logger.warning(f"[AUDIO_UNIVERSAL] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å file_path (–æ–∂–∏–¥–∞–µ–º–æ –¥–ª—è —Ñ–∞–π–ª–æ–≤ >{telegram_api_limit / (1024*1024):.0f}–ú–ë): {e}")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    await processing_msg.edit_text(
                        f"üìÅ **–ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª –æ–±–Ω–∞—Ä—É–∂–µ–Ω**\n\n"
                        f"üìä –†–∞–∑–º–µ—Ä: {file_size / (1024*1024):.1f} –ú–ë\n"
                        f"ü§ñ **–ò—Å–ø–æ–ª—å–∑—É—é —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ä–∞–±–æ—Ç–∫–∏...**\n"
                        f"‚ö° –†–∞–∑–±–∏–≤–∞—é –Ω–∞ —á–∞—Å—Ç–∏ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é",
                        parse_mode="Markdown"
                    )
                    
                    # –ü–æ–ª—É—á–∞–µ–º audio_service
                    async with self.get_session() as session:
                        audio_service = get_audio_processing_service(session)
                        
                        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å
                        transcript_text = await try_process_large_audio(
                            bot_token=bot_token,
                            file_id=file_id,
                            file_path=file_path,
                            file_size=file_size,
                            audio_service=audio_service
                        )
                    
                    if transcript_text:
                        logger.info(f"[AUDIO_UNIVERSAL] –ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: {len(transcript_text)} —Å–∏–º–≤–æ–ª–æ–≤")
                        
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                        async with self.get_session() as session:
                            user_service = get_user_service_with_session(session)
                            user = await user_service.get_user_by_telegram_id(message.from_user.id)
                            if not user:
                                # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                                user_data = {
                                    "id": message.from_user.id,
                                    "username": message.from_user.username,
                                    "first_name": message.from_user.first_name,
                                    "last_name": message.from_user.last_name,
                                    "language_code": message.from_user.language_code or "ru",
                                    "is_bot": message.from_user.is_bot,
                                    "is_premium": getattr(message.from_user, "is_premium", False)
                                }
                                user = await user_service.register_user(user_data)
                                if not user:
                                    logger.error(f"[AUDIO_UNIVERSAL] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.id}")
                                    await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                                    return

                            transcript_service = get_transcript_service(session)
                            transcript = await transcript_service.save_transcript(
                                user_id=user.id,
                                transcript_data=transcript_text.encode('utf-8'),
                                metadata={
                                    "source": "large_audio",
                                    "duration": duration,
                                    "file_id": file_id,
                                    "file_name": file_name,
                                    "file_size": file_size,
                                    "word_count": len(transcript_text.split()) if transcript_text else 0,
                                    "processing_method": "chunked_large_file"
                                }
                            )
                            
                            if transcript and transcript.get("transcript_key"):
                                await self._send_transcript_result(message, transcript, processing_msg)
                                await state.set_state(TranscribeStates.result)
                                return
                    
                    # –ï—Å–ª–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
                    logger.warning(f"[AUDIO_UNIVERSAL] –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞")
                    
                except Exception as e:
                    logger.exception(f"[AUDIO_UNIVERSAL] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–æ–ª—å—à–æ–≥–æ —Ñ–∞–π–ª–∞: {e}")
                
                # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å
                await message.reply(
                    f"‚ùå **–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –±–æ–ª—å—à–æ–π —Ñ–∞–π–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏**\n\n"
                    f"üìä **–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞:** {file_size / (1024*1024):.1f} –ú–ë\n"
                    f"üìè **–õ–∏–º–∏—Ç Bot API:** {telegram_api_limit / (1024*1024):.0f} –ú–ë\n\n"
                    f"üîß **–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:**\n"
                    f"‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Ñ–∞–π–ª –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç (üìé ‚Üí –§–∞–π–ª)\n"
                    f"‚Ä¢ –†–∞–∑–¥–µ–ª–∏—Ç–µ —Ñ–∞–π–ª –Ω–∞ —á–∞—Å—Ç–∏ –º–µ–Ω—å—à–µ {telegram_api_limit / (1024*1024):.0f} –ú–ë\n"
                    f"‚Ä¢ –°–æ–∂–º–∏—Ç–µ –∞—É–¥–∏–æ –¥–æ –º–µ–Ω—å—à–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞\n\n"
                    f"üí° **–î–ª—è –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤:** —Å–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–Ω–æ–≤–æ –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç",
                    parse_mode="Markdown"
                )
                await state.set_state(TranscribeStates.error)
                return
                
            else:
                # –û–±—ã—á–Ω–æ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –¥–ª—è —Ñ–∞–π–ª–æ–≤ <= 20MB
                file = await message.bot.get_file(file_id)
                downloaded_file = await message.bot.download_file(file.file_path)

            # –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ–º
            async with self.get_session() as session:
                audio_service = get_audio_processing_service(session)
                result = await audio_service.process_audio(downloaded_file.getvalue())
                
                if not result.success:
                    logger.error(f"[AUDIO_UNIVERSAL] –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏: {result.error}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –∞—É–¥–∏–æ.")
                    return
                
                text = result.text
                logger.info(f"[AUDIO_UNIVERSAL] –ü–æ–ª—É—á–µ–Ω —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞, –¥–ª–∏–Ω–∞: {len(text)}")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(message.from_user.id)
                if not user:
                    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    user_data = {
                        "id": message.from_user.id,
                        "username": message.from_user.username,
                        "first_name": message.from_user.first_name,
                        "last_name": message.from_user.last_name,
                        "language_code": message.from_user.language_code or "ru",
                        "is_bot": message.from_user.is_bot,
                        "is_premium": getattr(message.from_user, "is_premium", False)
                    }
                    user = await user_service.register_user(user_data)
                    if not user:
                        logger.error(f"[AUDIO_UNIVERSAL] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.id}")
                        await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                        return

                transcript_service = get_transcript_service(session)
                transcript = await transcript_service.save_transcript(
                    user_id=user.id,
                    audio_data=downloaded_file.getvalue(),
                    transcript_data=text.encode('utf-8'),
                    metadata={
                        "source": "audio",
                        "duration": duration,
                        "file_id": file_id,
                        "file_name": file_name,
                        "word_count": len(text.split()) if text else 0
                    }
                )
                
                if not transcript or not transcript.get("transcript_key"):
                    logger.error(f"[AUDIO_UNIVERSAL] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {transcript}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return
                    
                logger.info(f"[AUDIO_UNIVERSAL] –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {transcript}")

                await self._send_transcript_result(message, transcript, processing_msg)
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[AUDIO_UNIVERSAL] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ: {e}")
            await state.set_state(TranscribeStates.error)
            await message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )

    async def _handle_text_processing(self, message: Message, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –∏–∑ —Ñ–∞–π–ª–∞ .txt
        
        Args:
            message: –í—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ç–µ–∫—Å—Ç–æ–≤—ã–º —Ñ–∞–π–ª–æ–º
            state: –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
        """
        logger.info(f"[TEXT] –ü–æ–ª—É—á–µ–Ω —Ñ–∞–π–ª –æ—Ç user_id={message.from_user.id}, state={await state.get_state()}")
        try:
            if not message.document:
                await message.reply(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª",
                    reply_markup=get_back_to_menu_keyboard()
                )
                return
                
            file_name = message.document.file_name or ""
            mime_type = message.document.mime_type or ""
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
            if not (mime_type == "text/plain" or file_name.lower().endswith(".txt")):
                await message.reply(
                    f"‚ùå **–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞**\n\n"
                    f"üìÅ –§–∞–π–ª: {file_name}\n"
                    f"üè∑Ô∏è MIME —Ç–∏–ø: {mime_type}\n\n"
                    f"‚úÖ **–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:**\n"
                    f"üìù .txt —Ñ–∞–π–ª—ã (text/plain)\n\n"
                    f"üí° –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .txt",
                    parse_mode="Markdown",
                    reply_markup=get_back_to_menu_keyboard()
                )
                return

            processing_msg = await message.answer("üìù –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª...")
            await state.set_state(TranscribeStates.processing)

            file = await message.bot.get_file(message.document.file_id)
            file_bytes_io = await message.bot.download_file(file.file_path)
            text = file_bytes_io.read().decode("utf-8")
            file_name = message.document.file_name

            async with self.get_session() as session:
                text_service = get_text_processing_service(session)
                processed_text = await text_service.process_text(text)
                
                transcript_service = get_transcript_service(session)
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(message.from_user.id)
                
                if not user:
                    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    user_data = {
                        "id": message.from_user.id,
                        "username": message.from_user.username,
                        "first_name": message.from_user.first_name,
                        "last_name": message.from_user.last_name,
                        "language_code": message.from_user.language_code or "ru",
                        "is_bot": message.from_user.is_bot,
                        "is_premium": getattr(message.from_user, "is_premium", False)
                    }
                    user = await user_service.register_user(user_data)
                    if not user:
                        logger.error(f"[TEXT] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.id}")
                        await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                        return

                transcript = await transcript_service.save_transcript(
                    user_id=user.id,
                    transcript_data=processed_text.encode('utf-8'),
                    metadata={
                        "source": "text",
                        "length": len(text),
                        "file_name": file_name,
                        "word_count": len(processed_text.split()) if processed_text else 0
                    }
                )
                
                await self._send_transcript_result(message, transcript, processing_msg)
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[TEXT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞: {e}")
            await state.set_state(TranscribeStates.error)
            await message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞.\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )

    async def _handle_format_transcript(self, call: CallbackQuery, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
        
        Args:
            call: CallbackQuery —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
            state: –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ callback
            data = call.data.split("_")
            if len(data) < 4:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
                return

            transcript_id = safe_uuid(data[2])
            if not transcript_id:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                return

            format_type = data[3]
            await state.set_state(TranscribeStates.format_selection)

            async with self.get_session() as session:
                # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç
                transcript_service = get_transcript_service(session)
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(call.from_user.id)
                
                if not user:
                    logger.error(f"[FORMAT] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω: {call.from_user.id}")
                    await call.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return
                    
                content = await transcript_service.get_transcript_content(user.id, transcript_id)
                if not content:
                    logger.error(f"[FORMAT] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {transcript_id}")
                    await call.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return

                text = content.decode('utf-8')
                text_service = get_text_processing_service(session)
                
                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
                if format_type == "summary":
                    formatted_text = await text_service.format_summary(text)
                elif format_type == "todo":
                    formatted_text = await text_service.format_todo(text)
                elif format_type == "protocol":
                    formatted_text = await text_service.format_protocol(text)
                else:
                    logger.error(f"[FORMAT] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: {format_type}")
                    await call.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
                formatted_transcript = await transcript_service.save_transcript(
                    user_id=call.from_user.id,
                    transcript_data=formatted_text.encode('utf-8'),
                    metadata={
                        "source": "format",
                        "original_id": str(transcript_id),
                        "format_type": format_type
                    }
                )

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                await self._send_transcript_result(call.message, formatted_transcript, None)
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[FORMAT] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {e}")
            await state.set_state(TranscribeStates.error)
            await call.message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )

    def render_transcript_card(self, transcript: dict) -> str:
        """
        –§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
        """
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
        metadata = transcript.get("metadata", {})
        file_name = metadata.get("file_name", "–§–∞–π–ª")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞—Ç—É —Å–æ–∑–¥–∞–Ω–∏—è
        created_at = transcript.get("created_at")
        if isinstance(created_at, str):
            created_at_str = created_at.replace('T', ' ')[:16]
        elif created_at:
            created_at_str = created_at.strftime("%Y-%m-%d %H:%M")
        else:
            created_at_str = "‚Äî"
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
        transcript_type = "–ê—É–¥–∏–æ" if metadata.get("source") == "audio" else "–¢–µ–∫—Å—Ç"
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤
        word_count = metadata.get("word_count")
        if not word_count:
            text = transcript.get("text") or transcript.get("preview")
            if text:
                word_count = len(text.split())
            else:
                word_count = "‚Äî"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–µ–≤—å—é —Ç–µ–∫—Å—Ç–∞
        text_preview = transcript.get("preview")
        if not text_preview:
            text = transcript.get("text")
            if text:
                text_preview = text[:200] + "..." if len(text) > 200 else text
            else:
                text_preview = "‚Äî"
        
        card = (
            f"<b>–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç</b>\n"
            f"üìé –§–∞–π–ª: {file_name}\n"
            f"üìÖ –°–æ–∑–¥–∞–Ω: {created_at_str}\n"
            f"üìù –¢–∏–ø: {transcript_type}\n"
            f"üìä –°–ª–æ–≤: {word_count}\n\n"
            f"¬´{text_preview}¬ª"
        )
        return card

    async def _send_transcript_result(
        self, 
        message: Message, 
        transcript: Dict[str, Any], 
        status_message: Optional[Message] = None
    ) -> None:
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞ —Å —Ñ–∞–π–ª–æ–º.
        """
        try:
            if status_message:
                await status_message.delete()
            
            transcript_result = TranscriptResult(
                id=str(transcript["id"]),
                transcript_key=transcript["transcript_key"],
                metadata=transcript.get("metadata", {})
            )
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è preview –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞
            async with self.get_session() as session:
                transcript_service = get_transcript_service(session)
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(message.from_user.id)
                
                if not user:
                    await message.reply("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return
                    
                content = await transcript_service.get_transcript_content(user.id, safe_uuid(transcript["id"]))
                if not content:
                    await message.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return
                
                try:
                    text = content.decode("utf-8")
                    transcript["preview"] = text[:300] + "..." if len(text) > 300 else text
                    transcript["text"] = text  # –ü–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤
                except Exception as e:
                    logger.warning(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {e}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
                metadata = transcript.get("metadata", {})
                original_file_name = metadata.get("file_name")
                if original_file_name:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
                    file_name = original_file_name
                    if not file_name.endswith('.txt'):
                        file_name += '.txt'
                else:
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã –∏ ID
                    created_at = transcript.get("created_at", "")
                    if isinstance(created_at, str):
                        date_part = created_at[:10]  # YYYY-MM-DD
                    else:
                        date_part = "unknown"
                    file_name = f"{date_part}_transcript_{transcript['id'][:8]}.txt"
                
                # –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å –ø–æ–º–æ—â—å—é BufferedInputFile
                from aiogram.types import BufferedInputFile
                input_file = BufferedInputFile(content, filename=file_name)
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–∞—Ä—Ç–æ—á–∫—É —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
                keyboard = get_transcript_actions_keyboard(transcript_result.id)
                card_text = self.render_transcript_card(transcript)
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª —Å –∫–∞—Ä—Ç–æ—á–∫–æ–π –∫–∞–∫ caption
                await message.answer_document(
                    document=input_file,
                    caption=card_text,
                    reply_markup=keyboard,
                    parse_mode="HTML"
                )
                
        except Exception as e:
            logger.exception(f"[RESULT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: {e}")
            await message.answer(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞",
                reply_markup=get_back_to_menu_keyboard()
            )

    async def _handle_transcript_actions(self, call: CallbackQuery, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π —Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–º: summary, todo, protocol
        """
        try:
            # –†–∞–∑–±–∏—Ä–∞–µ–º callback data: transcript_summary_<id>, transcript_todo_<id>, etc.
            parts = call.data.split("_", 2)
            if len(parts) < 3:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
                return
            
            action = parts[1]  # summary, todo, protocol
            transcript_id = safe_uuid(parts[2])
            
            if not transcript_id:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                return
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ GPT
            await state.set_state(TranscribeStates.format_selection)
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            processing_msg = await call.message.answer("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç —Å –ø–æ–º–æ—â—å—é GPT...")

            async with self.get_session() as session:
                transcript_service = get_transcript_service(session)
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(call.from_user.id)
                
                if not user:
                    await call.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return
                    
                content = await transcript_service.get_transcript_content(user.id, transcript_id)
                if not content:
                    logger.error(f"[GPT] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {transcript_id}")
                    await processing_msg.edit_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return

                text = content.decode('utf-8')
                text_service = get_text_processing_service(session)
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ GPT
                if action == "summary":
                    formatted_text = await text_service.format_summary(text)
                    format_name = "–ö—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ"
                    file_prefix = "summary"
                elif action == "todo":
                    formatted_text = await text_service.format_todo(text)
                    format_name = "–°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á"
                    file_prefix = "todo"
                elif action == "protocol":
                    formatted_text = await text_service.format_protocol(text)
                    format_name = "–ü—Ä–æ—Ç–æ–∫–æ–ª"
                    file_prefix = "protocol"
                else:
                    logger.error(f"[GPT] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: {action}")
                    await processing_msg.edit_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
                    return

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∫ —Ñ–∞–π–ª
                from aiogram.types import BufferedInputFile
                file_data = formatted_text.encode('utf-8')
                input_file = BufferedInputFile(file_data, filename=f"{file_prefix}_{transcript_id}.txt")
                
                await processing_msg.delete()
                await call.message.answer_document(
                    document=input_file,
                    caption=f"üìÑ {format_name}",
                    reply_markup=get_back_to_transcript_keyboard(transcript_id)
                )
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[ACTIONS] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–µ–π—Å—Ç–≤–∏–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {e}")
            await state.set_state(TranscribeStates.error)
            await call.message.answer(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ.\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )

    async def _handle_transcript_format(self, call: CallbackQuery, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
        
        Args:
            call: CallbackQuery —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
            state: –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ callback
            data = call.data.split("_")
            if len(data) < 4:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
                return

            transcript_id = safe_uuid(data[2])
            if not transcript_id:
                await call.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                return

            format_type = data[3]
            await state.set_state(TranscribeStates.format_selection)

            async with self.get_session() as session:
                # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç
                transcript_service = get_transcript_service(session)
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(call.from_user.id)
                
                if not user:
                    logger.error(f"[FORMAT] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω: {call.from_user.id}")
                    await call.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return
                    
                content = await transcript_service.get_transcript_content(user.id, transcript_id)
                if not content:
                    logger.error(f"[FORMAT] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {transcript_id}")
                    await call.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return

                text = content.decode('utf-8')
                text_service = get_text_processing_service(session)
                
                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
                if format_type == "summary":
                    formatted_text = await text_service.format_summary(text)
                elif format_type == "todo":
                    formatted_text = await text_service.format_todo(text)
                elif format_type == "protocol":
                    formatted_text = await text_service.format_protocol(text)
                else:
                    logger.error(f"[FORMAT] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: {format_type}")
                    await call.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
                formatted_transcript = await transcript_service.save_transcript(
                    user_id=call.from_user.id,
                    transcript_data=formatted_text.encode('utf-8'),
                    metadata={
                        "source": "format",
                        "original_id": str(transcript_id),
                        "format_type": format_type
                    }
                )

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                await self._send_transcript_result(call.message, formatted_transcript, None)
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[FORMAT] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {e}")
            await state.set_state(TranscribeStates.error)
            await call.message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )

    async def _handle_back_to_transcribe_menu(self, call: CallbackQuery, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ –º–µ–Ω—é —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–≤
        """
        await call.answer()
        await state.set_state(TranscribeStates.waiting_text)

    async def _handle_audio_document(self, message: Message, state: FSMContext) -> None:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ —Ñ–∞–π–ª–æ–≤, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç—ã
        
        Args:
            message: –í—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∞—É–¥–∏–æ —Ñ–∞–π–ª–æ–º
            state: –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
        """
        logger.info(f"[AUDIO_DOCUMENT] –ü–æ–ª—É—á–µ–Ω –∞—É–¥–∏–æ —Ñ–∞–π–ª –æ—Ç user_id={message.from_user.id}, state={await state.get_state()}")
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç
            if not message.document:
                await message.reply(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç",
                    reply_markup=get_back_to_menu_keyboard()
                )
                return
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º MIME —Ç–∏–ø –∏–ª–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –¥–ª—è –∞—É–¥–∏–æ
            file_name = message.document.file_name or ""
            mime_type = message.document.mime_type or ""
            
            # –°–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –∞—É–¥–∏–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
            audio_extensions = ['.mp3', '.wav', '.m4a', '.ogg', '.flac', '.aac', '.wma', '.opus']
            is_audio_by_extension = any(file_name.lower().endswith(ext) for ext in audio_extensions)
            is_audio_by_mime = mime_type.startswith("audio/")
            
            if not (is_audio_by_mime or is_audio_by_extension):
                await message.reply(
                    f"‚ùå **–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞**\n\n"
                    f"üìÅ –§–∞–π–ª: {file_name}\n"
                    f"üè∑Ô∏è MIME —Ç–∏–ø: {mime_type}\n\n"
                    f"‚úÖ **–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:**\n"
                    f"üéµ MP3, WAV, M4A, OGG, FLAC\n"
                    f"üéµ AAC, WMA, OPUS\n\n"
                    f"üí° –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª",
                    parse_mode="Markdown",
                    reply_markup=get_back_to_menu_keyboard()
                )
                return

            file_size = message.document.file_size
            file_name = message.document.file_name
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
            processing_msg = await message.answer(
                f"üéµ **–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ —Ñ–∞–π–ª**\n\n"
                f"üìÅ –§–∞–π–ª: {file_name}\n"
                f"üìä –†–∞–∑–º–µ—Ä: {file_size / (1024*1024):.1f} –ú–ë\n"
                f"üîÑ –°–∫–∞—á–∏–≤–∞—é –∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é...",
                parse_mode="Markdown"
            )
            await state.set_state(TranscribeStates.processing)

            file = await message.bot.get_file(message.document.file_id)
            file_bytes_io = await message.bot.download_file(file.file_path)
            audio_data = file_bytes_io.read()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            await processing_msg.edit_text(
                f"üéµ **–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ —Ñ–∞–π–ª**\n\n"
                f"üìÅ –§–∞–π–ª: {file_name}\n"
                f"üìä –†–∞–∑–º–µ—Ä: {file_size / (1024*1024):.1f} –ú–ë\n"
                f"‚úÖ –°–∫–∞—á–∞–Ω: {len(audio_data) / (1024*1024):.1f} –ú–ë\n"
                f"ü§ñ –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é —á–µ—Ä–µ–∑ Whisper...",
                parse_mode="Markdown"
            )

            async with self.get_session() as session:
                audio_service = get_audio_processing_service(session)
                result = await audio_service.process_audio(audio_data)
                
                if not result.success:
                    logger.error(f"[AUDIO_DOCUMENT] –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏: {result.error}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –∞—É–¥–∏–æ.")
                    return
                
                text = result.text
                logger.info(f"[AUDIO_DOCUMENT] –ü–æ–ª—É—á–µ–Ω —Ç–µ–∫—Å—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞, –¥–ª–∏–Ω–∞: {len(text)}")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç
                user_service = get_user_service_with_session(session)
                user = await user_service.get_user_by_telegram_id(message.from_user.id)
                if not user:
                    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    user_data = {
                        "id": message.from_user.id,
                        "username": message.from_user.username,
                        "first_name": message.from_user.first_name,
                        "last_name": message.from_user.last_name,
                        "language_code": message.from_user.language_code or "ru",
                        "is_bot": message.from_user.is_bot,
                        "is_premium": getattr(message.from_user, "is_premium", False)
                    }
                    user = await user_service.register_user(user_data)
                    if not user:
                        logger.error(f"[AUDIO_DOCUMENT] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.id}")
                        await message.reply("‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                        return

                transcript_service = get_transcript_service(session)
                transcript = await transcript_service.save_transcript(
                    user_id=user.id,
                    audio_data=audio_data,
                    transcript_data=text.encode('utf-8'),
                    metadata={
                        "source": "audio",
                        "file_name": file_name,
                        "word_count": len(text.split()) if text else 0
                    }
                )
                
                if not transcript or not transcript.get("transcript_key"):
                    logger.error(f"[AUDIO_DOCUMENT] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {transcript}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞")
                    return
                    
                logger.info(f"[AUDIO_DOCUMENT] –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {transcript}")

                await self._send_transcript_result(message, transcript, processing_msg)
                await state.set_state(TranscribeStates.result)

        except Exception as e:
            logger.exception(f"[AUDIO_DOCUMENT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞: {e}")
            await state.set_state(TranscribeStates.error)
            await message.reply(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=get_back_to_menu_keyboard()
            )
