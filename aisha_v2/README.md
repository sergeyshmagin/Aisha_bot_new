# Aisha Bot V2

Новая версия Aisha Bot, построенная на принципах ООП с сохранением всей бизнес-логики оригинального проекта.

## Основные изменения (V2)

- Используется [aiogram](https://docs.aiogram.dev/) 3.x для асинхронного Telegram-бота
- FSM реализован через встроенные механизмы aiogram (StatesGroup, FSMContext)
- Вся обработка аудио вынесена в сервис `AudioProcessingService` (асинхронно, с поддержкой ffmpeg и Whisper API)
- Все хендлеры максимально тонкие, бизнес-логика — только в сервисах
- Покрытие unit-тестами: сервисы, обработчики, FSM

## Структура проекта

```
aisha_v2/
├── app/                    # Основной код приложения
│   ├── core/              # Ядро системы
│   │   ├── config.py      # Конфигурация и константы
│   │   ├── di.py         # Dependency Injection контейнер
│   │   └── types.py      # Общие типы и интерфейсы
│   ├── database/          # Слой работы с БД
│   │   ├── models.py     # SQLAlchemy модели
│   │   └── repositories/ # Репозитории
│   ├── services/         # Бизнес-логика (audio, avatar, transcript и др.)
│   ├── handlers/         # Обработчики команд (aiogram Router)
│   └── utils/           # Утилиты
├── tests/               # Тесты (pytest, pytest-asyncio)
├── alembic/            # Миграции БД
└── docs/               # Документация
    ├── ARCHITECTURE.md # Архитектура
    ├── API.md         # API документация
    └── CHANGELOG.md   # История изменений
```

## Аудио и транскрибация

- Поддержка голосовых и аудиофайлов (mp3/ogg)
- Конвертация в mp3 через ffmpeg (асинхронно)
- Нарезка по паузам (silencedetect, ffmpeg)
- Транскрибация через OpenAI Whisper API (с ретраями)
- Хранение файлов и транскриптов в MinIO
- FSM: пользователь переводится в режим ожидания аудио через команду `/audio`, после чего может отправить файл
- Все ошибки и статусы вынесены в `app/texts/audio_errors.py`
- Покрытие unit-тестами: `tests/services/test_audio_service.py`

## FSM и aiogram

- Для управления состояниями используется FSM aiogram (`StatesGroup`, `FSMContext`)
- Все переходы между состояниями документированы и покрыты тестами
- Регистрация хендлеров через Router и StateFilter
- Пример FSM для аудио:
  - `/audio` → ожидание файла → обработка → сброс состояния

## Тестирование

- Все сервисы покрыты unit-тестами (pytest, pytest-asyncio)
- Для моков используется unittest.mock/AsyncMock
- Проверяется обработка ошибок, граничные случаи, интеграция с MinIO и Whisper

## Основные принципы

1. Чистая архитектура с разделением на слои
2. Строгое следование SOLID принципам
3. Асинхронность везде (asyncio, aiohttp, SQLAlchemy 2)
4. 100% покрытие тестами критического кода
5. Документация как часть кода

## Разработка

1. Следуем PEP8 и black для форматирования
2. Каждый модуль <= 500 строк
3. Тесты пишутся сразу
4. Документация обновляется вместе с кодом
5. CI должен быть зеленым

## Правила разработки

1. Все константы в `core/constants.py`
2. Все конфиги через переменные окружения
3. Каждый коммит должен проходить все тесты
4. Новый код пишется с учетом существующей бизнес-логики
5. Параллельное тестирование с текущей версией

## База данных

### Модели

1. `users` - информация о пользователях
   - Основные данные из Telegram
   - Связи с аватарами, балансом и состоянием

2. `user_balances` - баланс пользователей
   - Количество монет
   - Связь один-к-одному с пользователем

3. `user_states` - состояния пользователей
   - JSON с данными состояния
   - Связь один-к-одному с пользователем

4. `avatars` - аватары пользователей
   - UUID как первичный ключ
   - Информация об аватаре (имя, пол, статус)
   - JSON для дополнительных данных

5. `avatar_photos` - фотографии аватаров
   - UUID как первичный ключ
   - Ключи MinIO для хранения файлов
   - Порядок фотографий

### Миграции

Используем Alembic для управления миграциями:

- Строка подключения к БД берётся из переменной окружения `DATABASE_URL` (см. `.env`) через Pydantic Settings (`app.core.config.settings`).
- Значение `sqlalchemy.url` в `alembic.ini` не используется, если запускается через приложение или если в окружении определён `DATABASE_URL`.
- Для автогенерации миграций убедитесь, что все модели импортированы в `app.database.models.Base`.
- Для запуска миграций:
  ```bash
  alembic upgrade head
  ```
- Для отката:
  ```bash
  alembic downgrade -1
  ```
- Перед применением миграций рекомендуется сделать бэкап БД.

## План развертывания

1. Настройка окружения (.env файл)
2. Установка зависимостей
3. Применение миграций БД
4. Запуск тестов
5. Запуск бота

## Быстрый старт (аудио)

1. Установить зависимости: `pip install -r requirements.txt`
2. Заполнить `.env` (см. переменные для MinIO, Whisper, Telegram)
3. Запустить миграции: `alembic upgrade head`
4. Запустить тесты: `pytest -q --tb=short`
5. Запустить бота: `python -m app.main`

## Ссылки
- docs/CLASSES_PLAN.md — структура классов
- docs/MIGRATION_PLAN.md — план миграции
- docs/TASK.md — задачи по транскрибации
- docs/UX_IMPROVEMENTS.md — улучшения UX/UI
